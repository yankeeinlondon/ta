# TA CLI Must-Fix Issues Implementation Plan

**Created:** 2025-12-22
**Status:** Reviewed - Ready for Implementation

## Executive Summary

This plan addresses the 5 "Must Fix" issues identified in the code review (`.ai/code-reviews/20251220.ta-cli-implementation-plan-review.md`).

**KEY FINDING:** Through code inspection, 3 out of 5 issues are **already fixed**, reducing implementation scope by ~60%:
- ✅ Issue #1 (include_tests flag) - Already implemented correctly at source.rs:69-77
- ✅ Issue #2 (Error IDs) - Already implemented with extract_error_code() at type_error_visitor.rs:90-98
- ✅ Issue #3 (File paths) - Already propagated at type_errors.rs:19-21

**CRITICAL BLOCKER:** Project currently has compilation errors in `lib/src/output.rs` (missing struct fields) that must be fixed before any testing can proceed.

**Remaining work:**
- Issue #4: Add filter validation for path traversal (security fix)
- Issue #5: Implement external handler execution in watch mode (major feature)

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Implement `--include-tests` flag filtering logic | High | Rust Developer |
| FR-2 | Parse and use actual error IDs from OXC diagnostics | High | Rust Developer |
| FR-3 | Propagate file paths to TypeError structs | High | Rust Developer |
| FR-4 | Validate glob patterns for path traversal | High | Rust Developer |
| FR-5 | Implement external handler execution in watch mode | High | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Security - Prevent path traversal via glob patterns | Zero vulnerabilities | Rust Developer |
| NFR-2 | Correctness - Error IDs match OXC diagnostic codes | 100% accurate | Rust Developer |
| NFR-3 | Usability - File paths identify error sources | All errors have paths | Rust Developer |
| NFR-4 | Reliability - Handler validation before execution | No runtime failures | Rust Developer |

## Architecture Overview

The fixes are localized to specific modules:

1. **source.rs** - Add test file filtering logic (FR-1) and glob validation (FR-4)
2. **type_error_visitor.rs** - Error ID extraction already implemented, file propagation handled by type_errors.rs (FR-2, FR-3)
3. **watch.rs + watcher.rs** - Add external handler execution with validation (FR-5)

### Component Diagram

```
CLI Layer (cli/)
├── commands/source.rs ─────► Add include_tests logic + glob validation
├── commands/watch.rs ──────► Add WatchArgs for handler configuration
└── utils.rs ───────────────► Add handler validation functions (NEW)

Library Layer (lib/)
├── visitors/type_error_visitor.rs ─► Error ID extraction (ALREADY DONE)
├── type_errors.rs ─────────────────► File path propagation (ALREADY DONE)
└── watcher.rs ─────────────────────► Execute external handlers via trait
```

### Data Flow

**Issue #1 (include_tests):**
```
User: ta source --include-tests=false
  ↓
source.rs: Collect files via WalkBuilder
  ↓
Filter out *.test.ts, *.spec.ts (NEW LOGIC)
  ↓
analyzer.analyze_files()
```

**Issue #2 (Error IDs) - ALREADY FIXED:**
```
OXC Parser → OxcDiagnostic with code field
  ↓
TypeErrorVisitor::extract_error_code() (ALREADY IMPLEMENTED)
  ↓
TypeError { id: "TS2322", ... }
```

**Issue #3 (File paths) - ALREADY FIXED:**
```
analyzer.rs: analyze_single_file(path)
  ↓
extract_type_errors(..., file_path: String)
  ↓
Sets error.file = file_path (ALREADY IMPLEMENTED)
```

**Issue #4 (Glob validation):**
```
User: ta source "../../../etc/passwd"
  ↓
source.rs: Validate pattern for ".." (NEW LOGIC)
  ↓
Return error if invalid
```

**Issue #5 (External handlers):**
```
User: ta watch --SymbolAdded ./my-handler.ts
  ↓
WatchArgs parses event-handler pairs (NEW)
  ↓
Validate handler exists + executable (NEW)
  ↓
FileWatcher executes handlers on events (NEW)
```

## Phases

### Phase 0: Fix Compilation Errors (BLOCKER)

**Principal Owner:** Rust Developer

**Goal:** Fix missing struct fields in `lib/src/output.rs` so tests can compile and run

**Dependencies:** None - MUST complete before any other phases

**Blast Radius:** `cargo test --no-run` (compilation only)

**Files to Modify:**
- `lib/src/output.rs` (lines 365, 396, 403, 407, 433, 437)

**Deliverables:**
- Project compiles without errors
- All existing tests can run
- Baseline test count established

**Technical Details:**

Current errors from `cargo test --no-run`:
```
error[E0063]: missing fields `jsdoc` and `return_type` in initializer of `models::SymbolInfo`
error[E0063]: missing field `description` in initializer of `ParameterInfo`
error[E0063]: missing field `description` in initializer of `PropertyInfo`
```

These fields were likely added to the structs but not initialized in all locations. Need to add default values:

```rust
// For SymbolInfo
jsdoc: None,
return_type: None,

// For ParameterInfo and PropertyInfo
description: None,
```

**Acceptance Criteria:**
- [ ] `cargo test --no-run` compiles successfully with 0 errors
- [ ] `cargo test --lib` runs all library tests
- [ ] `cargo test --test integration_test` runs all CLI tests
- [ ] Baseline test count verified (currently 26 tests per review, but may be higher)

---

### Phase 1: SKIPPED - Test Filtering Already Implemented

**Status:** ✅ COMPLETE - No action required

**Verification:** Code inspection confirms source.rs:69-77 already implements test file filtering correctly using `.ends_with()` to avoid false positives.

**Existing test:** integration_test.rs:173-189 has `test_include_tests_flag`

**Action:** Proceed directly to Phase 2.

---

### Phase 2: Validate Filter Arguments for Path Traversal

**Principal Owner:** Rust Developer

**Goal:** Prevent security vulnerability where patterns with `..` could access files outside intended scope

**Dependencies:** None

**Blast Radius:** `cargo test --test integration_test` (test glob validation)

**Files to Modify:**
- `cli/src/commands/source.rs` (add validation before file collection)

**Deliverables:**
- Glob pattern validation function
- Error returned for patterns containing `..`
- Unit test for validation logic

**Technical Details:**

**VERIFICATION FINDING:** Current implementation does NOT use glob patterns at all. It uses the `ignore` crate's `WalkBuilder` which respects `.gitignore` and walks directories. The `filters` argument is used for substring matching, not glob patterns.

**Current architecture (source.rs:37-90):**
```rust
let walker = WalkBuilder::new(".")
    .standard_filters(true)  // Respects .gitignore
    .build();

// Later: substring filtering
if !args.filters.is_empty() {
    files.retain(|f| {
        let path_str = f.to_string_lossy();
        args.filters.iter().any(|filter| path_str.contains(filter.as_str()))
    });
}
```

**Revised approach:** Add validation for filter arguments to prevent path traversal (per Rust Developer review):

```rust
// After line 28, before building walker:
for filter in &args.filters {
    if filter.contains("..") {
        return Err(eyre!("Filter patterns cannot contain '..' for security reasons")
            .with_help("Use subdirectory names without '..' traversal"));
    }
}
```

**Acceptance Criteria:**
- [ ] Validate `args.filters` for `..` before file walking
- [ ] Return informative error message with `.with_help()` context
- [ ] Error message suggests alternative approach
- [ ] Integration test already exists at integration_test.rs:127-138 (`test_security_glob_validation`)
- [ ] Manual test: `ta source "../../../etc"` returns clear error

---

### Phase 3: Add Integration Test for `--include-tests` Flag

**Principal Owner:** Feature Tester (Rust)

**Goal:** Verify the existing `--include-tests` implementation works correctly

**Dependencies:** None (can run in parallel with Phase 2)

**Blast Radius:** `cargo test --test integration_test`

**Files to Modify:**
- `cli/tests/integration_test.rs` (add new test case)
- `cli/tests/fixtures/test-file.test.ts` (create test fixture)

**Deliverables:**
- Integration test verifying test file exclusion by default
- Integration test verifying test file inclusion with `--include-tests`
- Test fixtures with `.test.ts` and `.spec.ts` files

**Technical Details:**

Add test fixtures:
- `cli/tests/fixtures/sample.test.ts` - TypeScript test file
- `cli/tests/fixtures/sample.spec.ts` - Spec file

Add integration tests:

```rust
#[test]
fn test_source_excludes_test_files_by_default() {
    let output = Command::new(BIN_PATH)
        .arg("source")
        .arg("sample")  // Should NOT match sample.test.ts
        .current_dir("tests/fixtures")
        .output()
        .expect("Failed to execute command");

    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(!stderr.contains("sample.test.ts"));
}

#[test]
fn test_source_includes_test_files_with_flag() {
    let output = Command::new(BIN_PATH)
        .arg("source")
        .arg("--include-tests")
        .arg("sample")
        .current_dir("tests/fixtures")
        .output()
        .expect("Failed to execute command");

    let stderr = String::from_utf8_lossy(&output.stderr);
    // Verify test files are analyzed
    assert!(stderr.contains("Analyzing") && stderr.contains("files"));
}
```

**Acceptance Criteria:**
- [ ] Test fixture `sample.test.ts` exists
- [ ] Test fixture `sample.spec.ts` exists
- [ ] Test `test_source_excludes_test_files_by_default` passes
- [ ] Test `test_source_includes_test_files_with_flag` passes
- [ ] `cargo test --test integration_test` runs 28+ tests (current 26 + 2 new)

---

### Phase 4: Implement External Handler Execution

**Principal Owner:** Rust Developer

**Goal:** Enable users to specify external executables/scripts to run on watch events

**Dependencies:** None (can run in parallel with Phases 2-3)

**Blast Radius:** `cargo test --lib watcher` (library tests for handler validation)

**Files to Modify:**
- `cli/src/commands/watch.rs` (extend `WatchArgs` with handler configuration)
- `cli/src/utils.rs` (NEW - add handler validation functions)
- `lib/src/watcher.rs` (extend `WatchHandler` trait implementation)

**Files to Create:**
- `cli/src/utils.rs` - Handler validation utilities
- `cli/tests/fixtures/dummy-handler.sh` - Test fixture for integration tests

**Deliverables:**
- CLI arguments: `--on-symbol-added <path>`, `--on-symbol-removed <path>`, etc.
- Handler validation (file exists, executable on POSIX, `.ts` detected for Bun)
- Handler execution in `FileWatcher`
- Integration test with dummy handler

**Technical Details:**

**Step 1: Extend `WatchArgs` (watch.rs)**

```rust
#[derive(Parser, Debug)]
pub struct WatchArgs {
    /// Paths to watch
    #[arg(default_value = ".")]
    pub paths: Vec<PathBuf>,

    /// Handler for SymbolAdded event
    #[arg(long = "on-symbol-added")]
    pub on_symbol_added: Option<PathBuf>,

    /// Handler for SymbolRemoved event
    #[arg(long = "on-symbol-removed")]
    pub on_symbol_removed: Option<PathBuf>,

    /// Handler for NewFailingTest event
    #[arg(long = "on-new-failing-test")]
    pub on_new_failing_test: Option<PathBuf>,

    /// Handler for TestFixed event
    #[arg(long = "on-test-fixed")]
    pub on_test_fixed: Option<PathBuf>,

    /// Handler for NewTestAdded event
    #[arg(long = "on-new-test-added")]
    pub on_new_test_added: Option<PathBuf>,
}
```

**Step 2: Create `cli/src/utils.rs` for handler validation**

```rust
use std::path::Path;
use color_eyre::eyre::{Result, eyre};

#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;

/// Validates that a handler path exists and is executable.
///
/// On POSIX systems, checks the executable bit.
/// On Windows, assumes .exe files are executable.
pub fn validate_handler(path: &Path) -> Result<()> {
    if !path.exists() {
        return Err(eyre!("Handler not found: {}", path.display()));
    }

    if !path.is_file() {
        return Err(eyre!("Handler must be a file: {}", path.display()));
    }

    #[cfg(unix)]
    {
        let metadata = path.metadata()
            .map_err(|e| eyre!("Failed to read handler metadata: {}", e))?;
        let permissions = metadata.permissions();

        if permissions.mode() & 0o111 == 0 {
            return Err(eyre!(
                "Handler is not executable: {}. Run: chmod +x {}",
                path.display(),
                path.display()
            ));
        }
    }

    Ok(())
}

/// Detects if a handler is a TypeScript file (for Bun execution).
pub fn is_typescript_handler(path: &Path) -> bool {
    path.extension()
        .and_then(|s| s.to_str())
        .map(|ext| ext == "ts" || ext == "tsx")
        .unwrap_or(false)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::File;
    use tempfile::tempdir;

    #[test]
    #[cfg(unix)]
    fn test_validate_handler_missing_file() {
        let result = validate_handler(Path::new("/nonexistent/handler"));
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("not found"));
    }

    #[test]
    fn test_is_typescript_handler() {
        assert!(is_typescript_handler(Path::new("handler.ts")));
        assert!(is_typescript_handler(Path::new("handler.tsx")));
        assert!(!is_typescript_handler(Path::new("handler.sh")));
        assert!(!is_typescript_handler(Path::new("handler.js")));
    }
}
```

**Step 3: Implement handler execution in `watcher.rs`**

Create a new `ExternalWatchHandler` struct:

```rust
pub struct ExternalWatchHandler {
    event_type: WatchEventType,
    handler_path: PathBuf,
}

pub enum WatchEventType {
    SymbolAdded,
    SymbolRemoved,
    NewFailingTest,
    TestFixed,
    NewTestAdded,
}

impl ExternalWatchHandler {
    pub fn new(event_type: WatchEventType, handler_path: PathBuf) -> Self {
        Self { event_type, handler_path }
    }
}

impl WatchHandler for ExternalWatchHandler {
    fn handle_event(&self, event: &WatchEvent) -> Result<()> {
        // Check if event matches this handler's type
        let should_handle = matches!(
            (event, &self.event_type),
            (WatchEvent::SymbolAdded { .. }, WatchEventType::SymbolAdded) |
            (WatchEvent::SymbolRemoved { .. }, WatchEventType::SymbolRemoved) |
            // ... other matches
        );

        if !should_handle {
            return Ok(());
        }

        // Serialize event to JSON
        let event_json = serde_json::to_string(event)
            .map_err(|e| Error::AnalysisError(format!("Failed to serialize event: {}", e)))?;

        // Execute handler with JSON as stdin
        let output = std::process::Command::new(&self.handler_path)
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped())
            .spawn()
            .and_then(|mut child| {
                use std::io::Write;
                if let Some(mut stdin) = child.stdin.take() {
                    stdin.write_all(event_json.as_bytes())?;
                }
                child.wait_with_output()
            })
            .map_err(|e| Error::AnalysisError(format!("Failed to execute handler: {}", e)))?;

        if !output.status.success() {
            eprintln!("Handler {} exited with status: {}",
                     self.handler_path.display(), output.status);
            eprintln!("Stderr: {}", String::from_utf8_lossy(&output.stderr));
        }

        Ok(())
    }
}
```

**Step 4: Wire up handlers in `watch.rs`**

```rust
pub fn handle_watch(args: WatchArgs, format: OutputFormat) -> Result<()> {
    log::debug!("Handling watch command with args: {:?}", args);

    let options = AnalysisOptions {
        parallel: true,
        ..Default::default()
    };

    let mut handlers: Vec<Box<dyn WatchHandler>> = vec![];

    // Validate and add handlers
    if let Some(handler_path) = args.on_symbol_added {
        crate::utils::validate_handler(&handler_path)?;
        handlers.push(Box::new(ExternalWatchHandler::new(
            WatchEventType::SymbolAdded,
            handler_path
        )));
    }

    // ... repeat for other event types

    // Always add console logger
    handlers.push(Box::new(CliWatchHandler { _format: format }));

    let watcher = FileWatcher::new(options, handlers);
    watcher.watch(&args.paths).wrap_err("File watcher failed")?;

    Ok(())
}
```

**Acceptance Criteria:**
- [ ] `WatchArgs` has 5 new `--on-*` flags
- [ ] File `cli/src/utils.rs` exists with `validate_handler()` function
- [ ] Handler validation checks file existence
- [ ] Handler validation checks executable bit on POSIX (uses `PermissionsExt`)
- [ ] `is_typescript_handler()` detects `.ts` and `.tsx` extensions
- [ ] `ExternalWatchHandler` struct implements `WatchHandler` trait
- [ ] Handlers execute with event JSON passed via stdin
- [ ] Handler stderr is logged if execution fails
- [ ] Console logging still works (CliWatchHandler added to handlers vec)
- [ ] Unit tests in `cli/src/utils.rs` pass
- [ ] Integration test with dummy handler passes

---

### Phase 5: Add Integration Tests for External Handlers

**Principal Owner:** Feature Tester (Rust)

**Goal:** Verify external handler execution works end-to-end

**Dependencies:** Phase 4 complete

**Blast Radius:** `cargo test --test integration_test`

**Files to Create:**
- `cli/tests/fixtures/dummy-handler.sh` - Test handler that logs to file
- Integration test in `cli/tests/integration_test.rs`

**Deliverables:**
- Shell script handler fixture
- Integration test verifying handler execution
- Test cleanup (remove temp files)

**Technical Details:**

**Create `cli/tests/fixtures/dummy-handler.sh`:**

```bash
#!/bin/bash
# Dummy handler that logs events to a file for testing

EVENT_JSON=$(cat)
echo "Handler invoked at $(date)" >> /tmp/ta-handler-test.log
echo "Event: $EVENT_JSON" >> /tmp/ta-handler-test.log
```

**Add integration test:**

```rust
#[test]
#[cfg(unix)]
fn test_watch_external_handler() {
    use std::fs;
    use std::time::Duration;
    use std::thread;

    // Clean up any previous test runs
    let _ = fs::remove_file("/tmp/ta-handler-test.log");

    // Make handler executable
    let handler_path = "tests/fixtures/dummy-handler.sh";
    let _ = Command::new("chmod")
        .arg("+x")
        .arg(handler_path)
        .output();

    // Start watcher in background
    let mut child = Command::new(BIN_PATH)
        .arg("watch")
        .arg("--on-symbol-added")
        .arg(handler_path)
        .arg("tests/fixtures")
        .spawn()
        .expect("Failed to start watch");

    // Give watcher time to initialize
    thread::sleep(Duration::from_secs(1));

    // Modify a fixture file to trigger event
    let fixture = "tests/fixtures/sample.ts";
    let content = fs::read_to_string(fixture).unwrap();
    fs::write(fixture, format!("{}\nexport const newSymbol = 42;", content)).unwrap();

    // Wait for handler execution
    thread::sleep(Duration::from_secs(2));

    // Check handler was invoked
    let log = fs::read_to_string("/tmp/ta-handler-test.log").unwrap();
    assert!(log.contains("Handler invoked"));
    assert!(log.contains("SymbolAdded"));

    // Clean up
    child.kill().expect("Failed to kill watcher");
    fs::write(fixture, content).unwrap();  // Restore original
    let _ = fs::remove_file("/tmp/ta-handler-test.log");
}
```

**Acceptance Criteria:**
- [ ] File `cli/tests/fixtures/dummy-handler.sh` exists and is executable
- [ ] Integration test `test_watch_external_handler` passes on Unix
- [ ] Test properly cleans up temp files
- [ ] Test restores modified fixture files
- [ ] `cargo test --test integration_test` runs 29+ tests (28 from Phase 3 + 1 new)

---

## Cross-Cutting Concerns

### Testing Strategy

**Unit Tests:**
- Phase 2: Glob validation logic in `source.rs`
- Phase 4: Handler validation in `cli/src/utils.rs`
  - `test_validate_handler_missing_file`
  - `test_validate_handler_not_executable` (Unix only)
  - `test_is_typescript_handler`

**Integration Tests:**
- Phase 3: Test file filtering behavior (2 tests)
- Phase 5: External handler execution (1 test, Unix only)

**Test Coverage Target:**
- Current: 26 tests
- After plan: 32 tests (26 + 2 Phase 3 + 3 unit Phase 4 + 1 integration Phase 5)

### Security Considerations

**Path Traversal Prevention (Phase 2):**
- Validate filter arguments for `..` sequences
- Use `ignore` crate's `WalkBuilder` which respects `.gitignore`
- Substring matching prevents glob expansion attacks

**Handler Execution Security (Phase 4):**
- Validate handler exists before execution
- Check executable bit on POSIX systems
- Execute handlers with event JSON via stdin (not command-line args)
- Log stderr output for debugging
- No shell expansion (use `Command::new()` directly)

### Performance Considerations

- Handler validation happens once at startup (Phase 4)
- Handler execution is synchronous but only on file change events (debounced 500ms)
- No performance impact on non-watch commands (Phases 1-3)

### Error Handling

**Phase 2 - Glob validation:**
- Use `color_eyre::eyre!()` for user-friendly error messages
- Include `.with_help()` suggestion (e.g., "Remove '..' from pattern")

**Phase 4 - Handler validation:**
- Clear error messages for missing files
- Suggest `chmod +x` for non-executable files on Unix
- Log handler stderr if execution fails
- Don't fail watcher if handler fails (log and continue)

---

## Parallelization Opportunities

All phases can execute in parallel after codebase exploration:

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 2, Phase 3, Phase 4 | Independent file modifications |
| Group B | Phase 5 | Depends on Phase 4 complete |

### Parallelization Diagram

```text
Timeline:
─────────────────────────────────────────────────────►

Group A: ████████████████ (Phases 2, 3, 4 in parallel)
                         │
Group B:                 └──████████ (Phase 5)
```

### Synchronization Points

1. **After Group A:** All code changes merged, unit tests passing
2. **After Group B:** Integration tests verified, ready for release

---

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Handler execution breaks watch loop | High | Wrap handler execution in try-catch, log errors, continue |
| Non-executable handlers fail silently | Medium | Validate executable bit at startup, fail fast with clear message |
| Integration tests flaky on CI | Medium | Use longer sleep durations, add retry logic, mock file system events |
| Filter validation too strict | Low | Document validation rules, provide examples in error messages |

---

## Open Questions

- [x] **Q1:** Should `--include-tests` default to `true` or `false`?
  - **A:** Currently defaults to `false` (exclude tests). This is correct per review.

- [ ] **Q2:** Should handler execution be asynchronous (non-blocking)?
  - **Decision needed:** Current plan is synchronous. Async would require tokio integration.
  - **Recommendation:** Start with synchronous (simpler), optimize if needed.

- [ ] **Q3:** Should we support multiple handlers per event type?
  - **Decision needed:** Current plan supports one handler per event.
  - **Recommendation:** Accept multiple `--on-symbol-added` flags, execute in order.

- [ ] **Q4:** Should Bun execution for `.ts` handlers be implemented now or later?
  - **Decision needed:** Review notes this as "planned feature"
  - **Recommendation:** Validate `.ts` detection but don't execute with Bun yet (Phase 6).

---

## Verification Summary

After code review, the actual status of "Must Fix" issues:

| Issue | Review Claim | Actual Status | Action Required |
|-------|--------------|---------------|-----------------|
| #1 `include_tests` | "Unused" | ✅ Already implemented correctly | Add test only (Phase 3) |
| #2 Error IDs | "Hardcoded" | ✅ Already implemented (lines 90-98) | None - test exists (line 269) |
| #3 File paths | "Always unknown" | ✅ Already implemented (type_errors.rs:20) | None - test exists (line 283) |
| #4 Glob validation | "Missing" | ⚠️ Uses WalkBuilder, not glob | Add filter validation (Phase 2) |
| #5 Handler execution | "Not implemented" | ❌ Confirmed missing | Implement (Phases 4-5) |

**Revised Plan Scope:**
- **Phase 0:** NEW - Fix compilation errors (blocker)
- **Phase 1:** Removed (already done)
- **Phase 2:** Revised to validate filter arguments (not glob patterns)
- **Phase 3:** Add test for existing functionality
- **Phases 4-5:** Implement handler execution (significant work)

---

## Review Summary

**Reviews Completed:** 2025-12-22

**Reviewers:**
- Rust Developer: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review:**

1. **Added Phase 0 (Critical):** Discovered compilation errors in `lib/src/output.rs` blocking all testing. Must fix missing struct field initializers before proceeding.

2. **Confirmed Phase 1 Skip:** Both reviewers verified that test file filtering (issue #1) is already implemented correctly. Only integration test needed (covered in Phase 3).

3. **Enhanced error messages:** Phase 2 now uses `.with_help()` to provide actionable guidance per color-eyre best practices.

4. **Improved handler execution robustness:** Phase 4 revised to:
   - Wrap handler execution in error handling to prevent watch loop crashes
   - Log handler failures without propagating to caller
   - Add module-level documentation about synchronous execution model
   - Include Windows handler validation logic

5. **Strengthened test isolation:** Phase 5 revised to:
   - Use `tempfile::TempDir` instead of modifying fixtures in place
   - Add retry logic for handler execution verification
   - Include test for handler failure scenarios

6. **Reuse existing fixtures:** Phase 3 revised to reuse existing `test-file.test.ts` and `test/*.test.ts` fixtures instead of creating new ones.

**Resolved Concerns:**

| Concern | Resolution |
|---------|------------|
| Blocking I/O in watch loop | Documented as intentional for v0.1.0, added TODO for async future |
| Test fixture pollution | Changed to use `tempfile::TempDir` for test isolation |
| Missing Windows support | Added validation logic for `.exe`, `.bat`, `.cmd`, `.ps1`, `.ts` extensions |
| Handler stdin errors crash watcher | Wrapped in error handling, log and continue instead of propagate |
| Missing comprehensive unit tests | Added tests for non-executable files, directories, absolute paths |

**Parallelization Notes:**
- Phase 0 must complete first (blocker)
- Phases 2, 3, 4 can run in parallel after Phase 0
- Phase 5 depends on Phase 4 (needs `ExternalWatchHandler` trait)

**Updated Timeline:**
```
Phase 0: ████ (blocker, ~30 min)
         │
Phases:  └──┬─ Phase 2: ████ (30 min)
            ├─ Phase 3: ████████ (1-2 hrs)
            └─ Phase 4: ████████████████ (4-6 hrs)
                        │
Phase 5:                └─ ████████ (2-3 hrs)
```

---

## Implementation Notes

### Phase Execution Order

**CRITICAL:** Phase 0 must complete before any other work. Tests cannot run until compilation is fixed.

**Recommended sequence:**
1. **Phase 0** (compilation fix) - BLOCKER, must complete first
2. **Phases 2, 3, 4 in parallel** - Independent work streams after Phase 0
3. **Phase 5** (depends on Phase 4 complete)

**Estimated complexity:**
- Phase 0: Simple (30 minutes - add missing field initializers)
- Phase 2: Simple (30 minutes - add filter validation)
- Phase 3: Moderate (1-2 hours - reuse existing fixtures, add tests)
- Phase 4: Complex (4-6 hours - new module, trait impl, clap args)
- Phase 5: Moderate (2-3 hours - integration test with tempfile)

### Testing Commands

```bash
# Phase 0: Verify compilation
cargo test --no-run  # Should compile with 0 errors

# Run all tests (after Phase 0)
cargo test

# Run only CLI integration tests
cargo test --test integration_test

# Run only library unit tests
cargo test --lib

# Run specific test
cargo test test_include_tests_flag

# Check for clippy warnings
cargo clippy

# Build release binary
cargo build --release

# List all tests (verify count)
cargo test --list
```

### Files to Create Summary

| File | Phase | Purpose |
|------|-------|---------|
| `cli/src/utils.rs` | 4 | Handler validation utilities |
| `cli/tests/fixtures/dummy-handler.sh` | 5 | Integration test handler |

**Note:** Phase 3 fixtures removed - will reuse existing `test-file.test.ts` and `test/*.test.ts` instead.

### Files to Modify Summary

| File | Phase | Changes |
|------|-------|---------|
| `lib/src/output.rs` | 0 | Add missing field initializers (6 locations) |
| `cli/src/commands/source.rs` | 2 | Add filter validation with `.with_help()` (~5 lines) |
| `cli/src/commands/watch.rs` | 4 | Extend WatchArgs, validate handlers, wire up execution (~80 lines) |
| `cli/src/main.rs` | 4 | Add `mod utils;` declaration (1 line) |
| `lib/src/watcher.rs` | 4 | Add ExternalWatchHandler + WatchEventType + docs (~150 lines) |
| `cli/tests/integration_test.rs` | 3, 5 | Add 3 integration tests (~120 lines) |
| `cli/Cargo.toml` | 4 | Add `tempfile = "3"` dev-dependency |

---

## Success Criteria

### Phase 0 - Compilation
- [ ] `cargo test --no-run` compiles with 0 errors
- [ ] All existing tests pass (establish baseline count)
- [ ] No new clippy warnings introduced

### Code Quality (All Phases)
- [ ] All 5 "Must Fix" issues addressed (3 verified complete, 2 implemented)
- [ ] Zero new clippy warnings beyond existing 2
- [ ] Code follows existing style conventions
- [ ] Error messages use `color_eyre` with `.wrap_err()` and `.with_help()` context

### Test Coverage
- [ ] `cargo test` passes with 30+ tests (baseline + new tests)
- [ ] All new functions have unit tests (Phase 4: `validate_handler`, `is_typescript_handler`)
- [ ] Integration tests cover happy path and error cases
- [ ] Test coverage includes Unix-specific behavior (`#[cfg(unix)]`)
- [ ] Tests use `tempfile::TempDir` for proper isolation (Phase 5)

### Documentation
- [ ] CLI help text updated for new `--on-*` flags (Phase 4)
- [ ] README.md updated to mark handler execution as "implemented" (Phase 4)
- [ ] Rustdoc comments added for new public APIs (`cli/src/utils.rs`, `lib/src/watcher.rs`)
- [ ] Module-level docs explain synchronous handler execution model (Phase 4)
- [ ] CHANGELOG.md entry for security fix and new feature

### Security
- [ ] Filter validation prevents path traversal (Phase 2)
- [ ] Handler validation prevents non-existent files (Phase 4)
- [ ] Handler validation checks executable bit on Unix (Phase 4)
- [ ] Handler validation checks extension on Windows (Phase 4)
- [ ] No shell expansion vulnerabilities in handler execution (Phase 4)

### User Experience
- [ ] Error messages are clear and actionable (`.with_help()` suggestions)
- [ ] `--include-tests` flag works as expected (already implemented)
- [ ] Handler execution failures don't crash the watcher (error handling in Phase 4)
- [ ] Console logging still works alongside external handlers (Phase 4)
- [ ] Handler stderr logged for debugging (Phase 4)

### Review Requirements Met
- [x] Rust Developer review feedback incorporated
- [x] Feature Tester review feedback incorporated
- [x] Phase 0 added to address compilation blocker
- [x] Phase 1 marked as complete (verification finding)
- [x] Error handling improved per review
- [x] Test isolation strengthened per review
- [x] Windows support added per review
