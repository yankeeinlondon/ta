# Fix "Must Fix Before 1.0" Issues - TA CLI

**Created:** 2025-12-22
**Status:** Reviewed - Ready for Implementation
**Review Document:** `.ai/code-reviews/20251220.ta-cli-implementation-plan-review.md`

## Executive Summary

**MAJOR REVISION:** After parallel sub-agent review and codebase analysis, this plan has been significantly revised. Of the 5 original "Must Fix" issues, **only 1 remains**: implementing external handler execution for watch mode.

**Resolution Summary:**
- ✅ TypeError.file field - Already working (set in visitor, updated in type_errors.rs)
- ✅ TypeError.id field - Already working (extracted via extract_error_code())
- ✅ Test file filtering - Already implemented (source.rs:68-77)
- ✅ Glob pattern validation - Not applicable (uses substring filters, not globs)
- ❌ External handler execution - **Needs implementation** (only logs to console currently)

This plan focuses on implementing Phase 1: External Handler Execution with comprehensive validation, error handling, and testing.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner | Files Affected |
|----|-------------|----------|-------|----------------|
| FR-1 | Watch mode supports external handler execution | High | Rust Developer | `cli/src/commands/watch.rs` |
| FR-2 | Handler validation (exists, executable, Bun check) | High | Rust Developer | `cli/src/commands/watch.rs` |
| FR-3 | Handler receives event data via environment variables | High | Rust Developer | `cli/src/commands/watch.rs` |
| FR-4 | Handler execution is non-blocking with timeout | High | Rust Developer | `cli/src/commands/watch.rs` |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Security: Handler validation before execution | 100% of handlers validated | Rust Developer |
| NFR-2 | Performance: Handlers don't block file watching | Non-blocking execution | Rust Developer |
| NFR-3 | Reliability: Handler timeouts prevent hangs | 30 second timeout | Rust Developer |
| NFR-4 | Test coverage for new code | 100% of new functions tested | Feature Tester (Rust) |
| NFR-5 | No breaking changes to CLI API | Existing commands work unchanged | Rust Developer |

## Architecture Overview

The fixes maintain the existing architecture:

- **Library crate (`ta-lib`)**: Core analysis engine with OXC integration
- **CLI crate (`ta`)**: User-facing command-line interface with clap
- **TypeScript package (`ts`)**: Type definitions for watch handlers

Changes are isolated to:
1. CLI command argument processing (test file filtering, glob validation)
2. Watch handler infrastructure (external executable support)

### Component Diagram

```
┌─────────────────────────────────────────────────────┐
│ CLI Layer (ta)                                       │
│  ┌─────────────────┐    ┌────────────────────────┐ │
│  │ source.rs       │    │ watch.rs               │ │
│  │ - Test filter   │    │ - Handler validation   │ │
│  │ - Glob validate │    │ - Executor support     │ │
│  └─────────────────┘    └────────────────────────┘ │
└─────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────┐
│ Library Layer (ta-lib)                               │
│  ┌──────────────────────────────────────────────┐  │
│  │ watcher.rs                                    │  │
│  │ - Trait-based handler system                 │  │
│  │ - No changes needed (architecture correct)   │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

### Data Flow

1. **Test filtering**: CLI → WalkBuilder (respects .gitignore) → Filter by filename patterns → Analyzer
2. **Glob validation**: CLI receives pattern → Validate for `..` → Pass to WalkBuilder
3. **Watch handlers**: Watch event detected → Handler trait method → External executable validation → Execute with event data

## Issues Summary

### Issue to Fix (1)

| Issue | Location | Impact | Complexity |
|-------|----------|--------|------------|
| External handler execution missing | `cli/src/commands/watch.rs:46-59` | Watch mode feature incomplete | Medium-High |

### Already Resolved (4)

| Issue | Status | Location |
|-------|--------|----------|
| TypeError.file field | ✅ Working correctly | Set to "unknown" in visitor, then updated in `type_errors.rs:19-21` |
| TypeError.id field | ✅ Working correctly | Extracted via `extract_error_code()` in `type_error_visitor.rs:90-99` |
| `--include-tests` filtering | ✅ Already implemented | Test file filtering in `source.rs:68-77` |
| Glob pattern validation | ✅ Not applicable | Uses substring filters, not glob patterns (no security issue) |

## Phases

### Phase 1: Implement External Handler Execution for Watch Mode

**Principal Owner:** Rust Developer

**Goal:** Enable watch mode to execute external handlers (shell scripts, TypeScript files) when events occur with proper validation, non-blocking execution, and timeout handling

**Dependencies:** None

**Blast Radius:** `cargo test` (full suite - foundational watch infrastructure change)

**New Dependencies:**
- `which = "6.0"` - Cross-platform binary location (for Bun detection)

**Deliverables:**
- Handler configuration parsing in `WatchArgs`
- Handler validation (file exists, executable on POSIX)
- Handler execution logic
- TypeScript file detection for Bun execution
- Tests covering handler invocation

**Technical Details:**

**Files to Modify:**
1. `/Volumes/coding/personal/ta/cli/src/commands/watch.rs` (lines 17-59)
2. `/Volumes/coding/personal/ta/lib/src/watcher.rs` (minimal - architecture already correct)

**Current State:**
- `WatchArgs` (line 17-21): Only has `paths` and `format`
- `CliWatchHandler` (line 39-59): Only logs to console

**Implementation Plan:**

#### Step 3a: Extend `WatchArgs` to Accept Handlers

```rust
// In watch.rs around line 17
#[derive(Debug, Args)]
pub struct WatchArgs {
    /// Paths to watch
    #[arg(required = true)]
    pub paths: Vec<PathBuf>,

    /// Output format
    #[arg(short, long, value_enum, default_value = "console")]
    pub format: OutputFormat,

    // New: Event handlers
    /// Handler for SymbolAdded events
    #[arg(long = "SymbolAdded")]
    pub on_symbol_added: Option<PathBuf>,

    /// Handler for SymbolRemoved events
    #[arg(long = "SymbolRemoved")]
    pub on_symbol_removed: Option<PathBuf>,

    /// Handler for TestStatusChanged events
    #[arg(long = "TestStatusChanged")]
    pub on_test_status_changed: Option<PathBuf>,

    /// Handler for NewFailingTest events
    #[arg(long = "NewFailingTest")]
    pub on_new_failing_test: Option<PathBuf>,

    /// Handler for TestFixed events
    #[arg(long = "TestFixed")]
    pub on_test_fixed: Option<PathBuf>,

    /// Handler for NewTestAdded events
    #[arg(long = "NewTestAdded")]
    pub on_new_test_added: Option<PathBuf>,

    /// Generic handler for all events
    #[arg(long = "Handler")]
    pub on_any_event: Option<PathBuf>,
}
```

#### Step 3b: Create Handler Validation and Execution

```rust
// Add new struct for validated handlers (around line 40)
struct ValidatedHandler {
    path: PathBuf,
    is_typescript: bool,
}

impl ValidatedHandler {
    fn new(path: PathBuf) -> Result<Self> {
        // Validate file exists
        if !path.exists() {
            return Err(eyre!("Handler file does not exist: {}", path.display()))
                .with_help("Check that the path is correct and the file is accessible");
        }

        let is_typescript = path.extension()
            .and_then(|s| s.to_str())
            .map(|ext| ext == "ts" || ext == "tsx")
            .unwrap_or(false);

        // On POSIX, check executable bit (unless TypeScript)
        #[cfg(unix)]
        if !is_typescript {
            use std::os::unix::fs::PermissionsExt;
            let metadata = path.metadata()
                .wrap_err_with(|| format!("Failed to read metadata for {}", path.display()))?;
            let permissions = metadata.permissions();
            if permissions.mode() & 0o111 == 0 {
                return Err(eyre!("Handler file is not executable: {}", path.display()))
                    .with_help("Run: chmod +x {}", path.display());
            }
        }

        Ok(Self { path, is_typescript })
    }

    fn execute(&self, event_name: &str, event_json: &str) -> Result<()> {
        use std::process::Command;

        let output = if self.is_typescript {
            // Execute with Bun
            Command::new("bun")
                .arg(&self.path)
                .env("TA_EVENT", event_name)
                .env("TA_EVENT_DATA", event_json)
                .output()
                .wrap_err_with(|| format!("Failed to execute TypeScript handler with Bun: {}", self.path.display()))?
        } else {
            // Execute as shell script
            Command::new(&self.path)
                .env("TA_EVENT", event_name)
                .env("TA_EVENT_DATA", event_json)
                .output()
                .wrap_err_with(|| format!("Failed to execute handler: {}", self.path.display()))?
        };

        if !output.status.success() {
            eprintln!("Handler {} exited with status: {}", self.path.display(), output.status);
            eprintln!("stderr: {}", String::from_utf8_lossy(&output.stderr));
        }

        Ok(())
    }
}
```

#### Step 3c: Update `CliWatchHandler` to Use External Handlers

```rust
// Replace CliWatchHandler (lines 39-59)
struct CliWatchHandler {
    format: OutputFormat,
    handlers: HashMap<String, ValidatedHandler>,
    generic_handler: Option<ValidatedHandler>,
}

impl CliWatchHandler {
    fn new(format: OutputFormat, args: &WatchArgs) -> Result<Self> {
        let mut handlers = HashMap::new();

        // Validate and register event-specific handlers
        if let Some(path) = &args.on_symbol_added {
            handlers.insert("SymbolAdded".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_symbol_removed {
            handlers.insert("SymbolRemoved".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_test_status_changed {
            handlers.insert("TestStatusChanged".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_new_failing_test {
            handlers.insert("NewFailingTest".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_test_fixed {
            handlers.insert("TestFixed".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_new_test_added {
            handlers.insert("NewTestAdded".to_string(), ValidatedHandler::new(path.clone())?);
        }

        // Generic handler
        let generic_handler = args.on_any_event
            .as_ref()
            .map(|path| ValidatedHandler::new(path.clone()))
            .transpose()?;

        Ok(Self {
            format,
            handlers,
            generic_handler,
        })
    }

    fn dispatch_event(&self, event_name: &str, event_data: &serde_json::Value) -> Result<()> {
        let event_json = serde_json::to_string(event_data)?;

        // Execute event-specific handler if registered
        if let Some(handler) = self.handlers.get(event_name) {
            handler.execute(event_name, &event_json)?;
        }

        // Execute generic handler if registered
        if let Some(handler) = &self.generic_handler {
            handler.execute(event_name, &event_json)?;
        }

        // Always log to console (existing behavior)
        eprintln!("[{}] {}", event_name, event_json);

        Ok(())
    }
}

impl WatchHandler for CliWatchHandler {
    fn handle_symbol_added(&mut self, event: &WatchEvent) {
        let data = serde_json::json!({
            "file": event.file,
            "symbol": event.data,
        });
        let _ = self.dispatch_event("SymbolAdded", &data);
    }

    fn handle_symbol_removed(&mut self, event: &WatchEvent) {
        let data = serde_json::json!({
            "file": event.file,
            "symbol": event.data,
        });
        let _ = self.dispatch_event("SymbolRemoved", &data);
    }

    // ... (implement remaining WatchHandler trait methods similarly)
}
```

#### Step 3d: Update `handle_watch()` to Use New Handler System

```rust
// Modify handle_watch() function (around line 45)
pub fn handle_watch(args: WatchArgs) -> Result<()> {
    let handler = CliWatchHandler::new(args.format, &args)?;

    let mut watcher = FileWatcher::new(Box::new(handler))
        .wrap_err("Failed to create file watcher")?;

    for path in &args.paths {
        watcher.watch(path).wrap_err_with(|| {
            format!("Failed to watch path: {}", path.display())
        })?;
    }

    println!("Watching {} path(s) for changes. Press Ctrl+C to stop.", args.paths.len());

    watcher.run().wrap_err("File watcher encountered an error")?;

    Ok(())
}
```

**CLI Usage Examples:**
```bash
# Watch with shell script handler
ta watch src/ --SymbolAdded ./scripts/on-symbol-added.sh

# Watch with TypeScript handler (executed via Bun)
ta watch src/ --TestFixed ./handlers/test-fixed.ts

# Watch with generic handler for all events
ta watch src/ --Handler ./handlers/generic.sh

# Multiple handlers
ta watch src/ \
  --SymbolAdded ./handlers/symbol-added.sh \
  --TestFixed ./handlers/test-fixed.ts \
  --Handler ./handlers/log-all.sh
```

**Environment Variables Passed to Handlers:**
- `TA_EVENT`: Event name (e.g., "SymbolAdded", "TestFixed")
- `TA_EVENT_DATA`: JSON string with event details

**Acceptance Criteria:**
- [ ] File `/Volumes/coding/personal/ta/cli/src/commands/watch.rs` modified with >200 new lines
- [ ] `WatchArgs` struct has handler fields for all 6 event types + generic
- [ ] `ValidatedHandler` struct implements file validation and execution
- [ ] `CliWatchHandler` uses `HashMap` to dispatch to correct handlers
- [ ] `cargo build --bin ta` succeeds
- [ ] `cargo test` passes (full suite - watch is foundational)
- [ ] Manual test: Create executable script `test-handler.sh` with:
  ```bash
  #!/bin/bash
  echo "Event: $TA_EVENT"
  echo "Data: $TA_EVENT_DATA"
  ```
- [ ] Manual test: `chmod +x test-handler.sh && cargo run -p cli -- watch cli/tests/fixtures/ --Handler ./test-handler.sh`
- [ ] Manual test: Modify a file in fixtures and verify handler is executed
- [ ] Manual test: Try non-executable handler → expect error with help text
- [ ] Manual test: Try non-existent handler → expect error with help text
- [ ] Unit tests added for:
  - `ValidatedHandler::new()` with valid/invalid paths
  - `ValidatedHandler::new()` with executable/non-executable files (POSIX)
  - `ValidatedHandler::execute()` with shell scripts
  - `ValidatedHandler::execute()` with TypeScript files
- [ ] Integration test added that:
  - Creates temp handler script
  - Runs watch command with handler
  - Modifies a file
  - Verifies handler was called (check output or temp file)

**Implementation Notes:**
- Use `std::collections::HashMap` for handler dispatch
- Use `std::process::Command` for handler execution
- TypeScript detection: Check file extension `.ts` or `.tsx`
- POSIX executable check: `#[cfg(unix)]` with `std::os::unix::fs::PermissionsExt`
- Error messages should include `.with_help()` for user guidance

---

## Cross-Cutting Concerns

### Testing Strategy

#### Unit Tests
- **Location:** `#[cfg(test)] mod tests` blocks in modified files
- **Coverage Required:**
  - `validate_glob_pattern()` function (Phase 2)
  - `ValidatedHandler::new()` (Phase 3)
  - `ValidatedHandler::execute()` (Phase 3)
  - Test file filtering logic (Phase 1)

#### Integration Tests
- **Location:** `/Volumes/coding/personal/ta/cli/tests/integration_test.rs`
- **New Tests Required:**
  - `test_source_exclude_tests` - Verify test files excluded by default
  - `test_source_include_tests_flag` - Verify `--include-tests` includes test files
  - `test_source_invalid_glob_pattern` - Verify `..` patterns rejected
  - `test_watch_with_handler` - Verify external handler execution

#### Manual Testing Checklist
- [ ] Test file filtering: `ta source 'fixtures/**/*.ts'` excludes `.test.ts` files
- [ ] Test file inclusion: `ta source 'fixtures/**/*.ts' --include-tests` includes test files
- [ ] Glob validation: `ta source '../../../etc/passwd'` returns error
- [ ] Watch with shell handler: Create script, run `ta watch --Handler script.sh`, modify file
- [ ] Watch with TypeScript handler: Create `.ts` file, run with `--Handler`, verify Bun execution
- [ ] Watch handler validation: Try non-existent handler → error
- [ ] Watch handler validation: Try non-executable handler → error (POSIX only)

### Security Considerations

#### Path Traversal Prevention (Phase 2)
- Reject glob patterns containing `..`
- Defense in depth: `WalkBuilder` already respects `.gitignore`
- Error message guides users to safe patterns

#### Handler Execution Security (Phase 3)
- Validate handler files exist before execution
- Check executable permissions on POSIX systems
- Sandboxing: Handlers run in separate process (`std::process::Command`)
- No shell expansion of event data (pass via environment variables)

### Performance Considerations

#### Phase 1 - Test Filtering
- Impact: Negligible (post-processing filter on collected files)
- No additional file I/O required

#### Phase 2 - Glob Validation
- Impact: Negligible (single string contains check)
- Happens once per command invocation

#### Phase 3 - Handler Execution
- Impact: Depends on handler performance
- Asynchronous: Handler execution doesn't block file watching
- Current implementation: Synchronous execution in event handler (acceptable for v1.0)
- Future optimization: Use async/tokio for non-blocking handler execution

### Error Handling

#### Library Errors (thiserror)
- No changes needed - existing error types sufficient

#### CLI Errors (color-eyre)
- Add `.with_help()` to all new error messages
- Examples:
  - Glob validation: "Use absolute paths or patterns relative to current directory"
  - Handler validation: "Run: chmod +x <handler-path>"
  - Handler execution: "Check that Bun is installed: bun --version"

### Rust-Specific Patterns

#### Phase 1 - Test Filtering
- Use `Vec::retain()` for in-place filtering
- Use `Path::to_string_lossy()` for pattern matching

#### Phase 2 - Glob Validation
- Simple `str::contains()` check sufficient
- Use `eyre!()` macro for error creation

#### Phase 3 - Handler Execution
- Use `HashMap<String, ValidatedHandler>` for O(1) dispatch
- Use `Option<ValidatedHandler>` for generic handler
- Use `#[cfg(unix)]` for POSIX-specific code
- Use `std::os::unix::fs::PermissionsExt` for executable check

## Parallelization Opportunities

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 1, Phase 2 | Both modify `source.rs` but different sections - can be implemented independently |
| Group B | Phase 3 | Depends on Phase 2 complete (security validation must be in place first) |

**Implementation Strategy:**
1. Implement Phases 1 & 2 in parallel (different developers or feature branches)
2. Merge and test Phases 1 & 2 together
3. Implement Phase 3 after security validation is verified

**Timeline Diagram:**
```
─────────────────────────────────────────────────────►

Group A: ████████ (Phase 1 + Phase 2 in parallel)
                  │
Group B:          └──████████████ (Phase 3 - most complex)
```

**Synchronization Points:**
1. **After Group A:** Security validation and test filtering both working
2. **After Group B:** Full watch mode functionality with handler execution

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Handler execution breaks file watching | High | Low | Extensive testing; handlers run in separate process |
| Test filtering misses some test file patterns | Medium | Medium | Support multiple patterns (`.test.`, `.spec.`, `__tests__/`) |
| POSIX executable check fails on some systems | Medium | Low | Clear error messages with `chmod` instructions |
| TypeScript handler execution requires Bun | Medium | Medium | Validate Bun is installed; provide clear error if missing |
| Path traversal validation too restrictive | Low | Low | Only reject `..`, allow all other patterns |

## Open Questions

- [ ] **Phase 1:** Should `--include-tests` also affect other commands (symbols, test, deps)? Or just `source`?
  - **Recommendation:** Only `source` for v1.0, can extend later

- [ ] **Phase 3:** Should handler execution be asynchronous (non-blocking)?
  - **Recommendation:** Synchronous for v1.0, optimize to async in future if needed

- [ ] **Phase 3:** Should handlers receive structured event data or JSON strings?
  - **Recommendation:** JSON via environment variable `TA_EVENT_DATA` for simplicity

- [ ] **Phase 3:** Should we validate that Bun is installed when TypeScript handlers are provided?
  - **Recommendation:** Yes, check `which bun` during validation and provide clear error

## Appendix: Files Modified

### Phase 1
- **Modified:** `/Volumes/coding/personal/ta/cli/src/commands/source.rs` (lines 69-77)
- **Added:** Integration test in `/Volumes/coding/personal/ta/cli/tests/integration_test.rs`

### Phase 2
- **Modified:** `/Volumes/coding/personal/ta/cli/src/commands/source.rs` (add validation function, call before line 48)
- **Added:** Unit tests in `source.rs` `#[cfg(test)]` module

### Phase 3
- **Modified:** `/Volumes/coding/personal/ta/cli/src/commands/watch.rs` (substantial rewrite)
  - Lines 17-21: Extend `WatchArgs`
  - Lines 39-59: Replace `CliWatchHandler` with new implementation
  - Add: `ValidatedHandler` struct and implementation
- **Added:** Unit tests in `watch.rs` `#[cfg(test)]` module
- **Added:** Integration test in `/Volumes/coding/personal/ta/cli/tests/integration_test.rs`

### Dependencies
- **No new dependencies required** - all features use std library

## Success Metrics

- [ ] All 3 "Must Fix" issues resolved
- [ ] Zero new clippy warnings introduced
- [ ] Test coverage: 100% of new functions tested
- [ ] Manual testing checklist: 7/7 tests pass
- [ ] Documentation updated: README examples for handler usage
- [ ] Zero breaking changes to existing CLI commands

## Next Steps After Plan Approval

1. **Create feature branch:** `git checkout -b fix/must-issues-before-1.0`
2. **Implement Group A (parallel):**
   - Developer A: Phase 1 (test filtering)
   - Developer B: Phase 2 (glob validation)
3. **Merge and test Group A**
4. **Implement Group B:**
   - Phase 3 (handler execution)
5. **Full regression testing:** `cargo test` + manual testing
6. **Update documentation:** README examples for handlers
7. **Create pull request** with review checklist
