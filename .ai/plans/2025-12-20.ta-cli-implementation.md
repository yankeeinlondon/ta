# TA (TypeScript Analyzer) CLI - Complete Implementation Plan

**Created:** 2025-12-20
**Status:** Reviewed - Ready for Implementation
**Reviews Completed:** 2025-12-20

## Executive Summary

Build a high-performance TypeScript analyzer CLI from scratch using Rust, OXC for AST parsing, clap for CLI framework, and color-eyre for error handling. The project will implement type error detection, symbol analysis, dependency tracking, type test detection, and file watching capabilities with three output formats (Console/HTML/JSON).

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Workspace structure with lib/cli/ts modules | High | Rust Developer |
| FR-2 | Type error detection with scope/block context | High | Rust Developer |
| FR-3 | Exported symbol extraction with filtering | High | Rust Developer |
| FR-4 | File-level dependency analysis | High | Rust Developer |
| FR-5 | Symbol-level dependency analysis | High | Rust Developer |
| FR-6 | Type test detection in test files | Medium | Rust Developer |
| FR-7 | File watching with event handlers | Medium | Rust Developer |
| FR-8 | Console output with ANSI colorization | High | Rust Developer |
| FR-9 | HTML output with semantic markup + data-* attributes | Medium | Rust Developer |
| FR-10 | JSON output with embedded console/HTML representations | High | Rust Developer |
| FR-11 | CLI with 6 subcommands (source/symbols/test/file/deps/watch) | High | Rust Developer |
| FR-12 | TypeScript handler type definitions for watch events | Low | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Parse performance | Process 1000+ files in seconds using Rayon | Rust Developer |
| NFR-2 | Memory efficiency | Use OXC arena allocation, minimize clones | Rust Developer |
| NFR-3 | Error reporting | All errors use color-eyre with helpful context | Rust Developer |
| NFR-4 | Code quality | Pass cargo clippy with zero warnings | Rust Developer |
| NFR-5 | Test coverage | Unit tests for all extractors, integration tests for CLI | Feature Tester (Rust) |
| NFR-6 | Maintainability | Clear module boundaries, documented public APIs | Rust Developer |
| NFR-7 | Cross-platform | Build on Linux/macOS/Windows | Rust Developer |

## Architecture Overview

### Component Structure

```
ta (workspace root)
├── lib/               # Core analysis library
│   ├── analyzer.rs    # Coordinator for parallel file analysis
│   ├── type_errors.rs # Type error extraction using OXC semantic
│   ├── symbols.rs     # Symbol extraction with filtering
│   ├── dependencies.rs# File and symbol dependency analysis
│   ├── tests.rs       # Type test detection
│   ├── watcher.rs     # File watching and event dispatch
│   ├── models.rs      # Shared data structures (TypeError, SymbolInfo, etc.)
│   ├── output.rs      # Output format coordination
│   ├── colorize.rs    # ANSI escape codes and HTML generation
│   └── visitors/      # Custom OXC AST visitors
│       ├── mod.rs
│       ├── type_error_visitor.rs
│       ├── symbol_visitor.rs
│       └── dependency_visitor.rs
│
├── cli/               # CLI binary
│   ├── main.rs        # Clap command structure and dispatch
│   ├── commands/      # Subcommand implementations
│   │   ├── source.rs
│   │   ├── symbols.rs
│   │   ├── test.rs
│   │   ├── file.rs
│   │   ├── deps.rs
│   │   └── watch.rs
│   └── error.rs       # CLI-specific error types
│
└── ts/                # TypeScript handler types (optional)
    └── index.ts       # Handler function type exports
```

### Data Flow

1. **CLI Invocation** → Clap parses args → Dispatch to subcommand handler
2. **Subcommand Handler** → Call library analyzer with options
3. **Analyzer** → Use Rayon to process files in parallel
4. **Per-File Processing** → OXC parser → AST → Semantic analysis → Custom visitors
5. **Visitor Results** → Aggregate into models (TypeError, SymbolInfo, etc.)
6. **Output Formatter** → Match on OutputFormat → Generate Console/HTML/JSON
7. **Output** → Write to stdout (data) and stderr (status/progress)

### Key Dependencies

- **oxc_parser**: Parse TypeScript source → AST
- **oxc_semantic**: Build symbol table and semantic model
- **oxc_allocator**: Arena allocation for AST nodes
- **clap**: CLI argument parsing with derive API
- **color-eyre**: Pretty error reporting
- **serde**: Serialization for JSON output
- **rayon**: Parallel file processing
- **env_logger/log**: Logging to stderr
- **notify**: File watching for watch command

## Phases

### Phase 1: Project Foundation and Dependencies

**Principal Owner:** Rust Developer

**Goal:** Configure Cargo workspace, add all dependencies, establish error handling patterns

**Dependencies:** None

**Blast Radius:** `cargo test` (full suite - foundational changes)

**Files to create:**

- Root `Cargo.toml` - Workspace configuration with `[workspace]` section
- `lib/Cargo.toml` - Library dependencies (oxc crates, serde, rayon, thiserror, etc.)
- `cli/Cargo.toml` - CLI dependencies (clap, color-eyre, env_logger, etc.)
- `lib/src/error.rs` - Library error types using thiserror
- `cli/src/error.rs` - CLI error types using color-eyre

**Files to modify:**

- `lib/src/lib.rs` - Remove placeholder code, add public exports
- `cli/src/main.rs` - Remove "Hello, world!", add basic clap structure

**Dependencies to add:**

**lib/Cargo.toml:**

```toml
[dependencies]
oxc_parser = "0.30"
oxc_semantic = "0.30"
oxc_allocator = "0.30"
oxc_span = "0.30"
oxc_ast = "0.30"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
rayon = "1.10"
thiserror = "2.0"
glob = "0.3"
notify = "7.0"
log = "0.4"

[dev-dependencies]
proptest = "1"
insta = "1"
tempfile = "3"
pretty_assertions = "1"
```

**cli/Cargo.toml:**

```toml
[dependencies]
ta-lib = { path = "../lib" }
clap = { version = "4.5", features = ["derive", "env"] }
color-eyre = "0.6"
env_logger = "0.11"
log = "0.4"

[dev-dependencies]
assert_cmd = "2"
predicates = "3"
```

**Deliverables:**

- Workspace builds with `cargo build`
- All dependencies resolve correctly
- Error types compile
- Basic CLI skeleton with `--help` works

**Technical Details:**

- Use `[workspace]` with `members = ["lib", "cli"]` and `edition = "2021"` in workspace.package
- Library error enum with variants: ParseError, SemanticError, IoError, InvalidSourceType
- CLI error enum with variants: Config, Analysis, Io, InvalidArgs
- Implement `From<lib::Error>` for `cli::Error`
- CLI main returns `color_eyre::Result<()>`
- Add release profile optimizations for performance
- Install `cargo-nextest` as development tool for faster test execution

**Acceptance Criteria:**

- [ ] File `Cargo.toml` exists with workspace configuration including edition = "2021" (>20 lines)
- [ ] File `lib/Cargo.toml` lists oxc_parser=0.30, oxc_semantic=0.30, oxc_allocator=0.30, serde, rayon, thiserror
- [ ] File `lib/Cargo.toml` lists dev-dependencies: proptest, insta, tempfile, pretty_assertions
- [ ] File `cli/Cargo.toml` lists clap with derive feature, color-eyre, ta-lib path dependency
- [ ] File `cli/Cargo.toml` lists dev-dependencies: assert_cmd, predicates
- [ ] File `lib/src/error.rs` exists with thiserror-based error types (>40 lines)
- [ ] File `cli/src/error.rs` exists with color-eyre integration (>30 lines)
- [ ] `cargo build` succeeds with zero warnings
- [ ] `cargo run -p cli -- --help` displays help text
- [ ] `cargo clippy` passes with zero warnings
- [ ] Documentation includes `cargo install cargo-nextest` as development dependency

---

### Phase 2: Core Data Models and Output System

**Principal Owner:** Rust Developer

**Goal:** Define all shared data structures and output formatting infrastructure

**Dependencies:** Phase 1 complete

**Blast Radius:** `cargo test --lib` (library tests only)

**Files to create:**

- `lib/src/models.rs` - All core data structures (TypeError, SymbolInfo, FileDependencies, etc.)
- `lib/src/output.rs` - OutputFormat enum and OutputFormatter struct
- `lib/src/colorize.rs` - ANSI escape codes and HTML generation utilities

**Data structures to implement:**

```rust
// In models.rs
pub struct TypeError {
    pub id: String,
    pub message: String,
    pub file: String,
    pub line: usize,
    pub column: usize,
    pub scope: String,  // "file::symbol" format
    pub block: String,  // Plain text code block
    pub span: Span,
}

pub struct SymbolInfo {
    pub name: String,
    pub kind: SymbolKind,
    pub file: String,
    pub start_line: usize,
    pub end_line: usize,
    pub exported: bool,
    pub parameters: Option<Vec<ParameterInfo>>,
    pub properties: Option<Vec<PropertyInfo>>,
}

pub enum SymbolKind {
    Function,
    Class,
    Interface,
    Type,
    Variable,
    Enum,
}

pub struct FileDependencies {
    pub file: String,
    pub repo_dependencies: Vec<String>,
    pub external_dependencies: Vec<String>,
}

pub struct SymbolDependencies {
    pub symbol: String,
    pub file: String,
    pub dependencies: Vec<SymbolDependency>,
}

pub struct SymbolDependency {
    pub name: String,
    pub scope: DependencyScope,
    pub file: Option<String>,
}

pub enum DependencyScope {
    Local,
    Repo,
    Module,
    External,
}

pub struct TypeTest {
    pub file: String,
    pub describe_block: String,
    pub test_name: String,
    pub line: usize,
    pub has_type_cases: bool,
    pub status: TestStatus,
}

pub enum TestStatus {
    Passing,
    Failing,
    NoTypeCases,
}
```

**Output system to implement:**

```rust
// In output.rs
pub enum OutputFormat {
    Console,
    Html,
    Json,
}

pub struct OutputFormatter;

impl OutputFormatter {
    pub fn format_type_errors(errors: &[TypeError], format: OutputFormat) -> String;
    pub fn format_symbols(symbols: &[SymbolInfo], format: OutputFormat) -> String;
    // ... other formatters
}
```

**Colorization to implement:**

```rust
// In colorize.rs
pub const RED: &str = "\x1b[31m";
pub const GREEN: &str = "\x1b[32m";
// ... other ANSI codes

pub struct ConsoleColorizer;
impl ConsoleColorizer {
    pub fn colorize_code_block(code: &str, language: &str) -> String;
    pub fn highlight_error(error_span: &Span, source: &str) -> String;
}

pub struct HtmlColorizer;
impl HtmlColorizer {
    pub fn colorize_code_block(code: &str, language: &str) -> String;
    pub fn highlight_error(error: &TypeError, source: &str) -> String;
}
```

**Deliverables:**

- All data models implement `Serialize`, `Debug`, `Clone`
- Output formatter produces valid JSON, HTML, and ANSI-colored console output
- Colorizers handle TypeScript syntax highlighting

**Technical Details:**

- Use `#[derive(Serialize, Debug, Clone)]` on all models
- Implement `Display` trait for human-readable console output
- HTML output wraps content in `<span>` with data-* attributes
- JSON output includes `console` and `html` fields with pre-formatted strings
- ANSI colorization uses consistent color scheme (keywords=blue, strings=green, etc.)

**Acceptance Criteria:**

- [ ] File `lib/src/models.rs` exists with all 8+ data structures (>300 lines)
- [ ] `grep "pub struct TypeError" lib/src/models.rs` succeeds
- [ ] `grep "pub enum SymbolKind" lib/src/models.rs` succeeds
- [ ] `grep "pub enum DependencyScope" lib/src/models.rs` succeeds
- [ ] File `lib/src/output.rs` exists with OutputFormatter (>200 lines)
- [ ] File `lib/src/colorize.rs` exists with ANSI and HTML colorizers (>250 lines)
- [ ] `cargo test models` runs 10+ tests
- [ ] `cargo test output` runs 8+ tests for each output format
- [ ] `cargo test colorize` runs 6+ tests for syntax highlighting
- [ ] All tests pass

---

### Phase 3: OXC Integration and AST Visitors

**Principal Owner:** Rust Developer

**Goal:** Implement custom AST visitors for type error detection, symbol extraction, and dependency analysis

**Dependencies:** Phase 2 complete

**Blast Radius:** `cargo test --lib` (library tests only)

**Files to create:**

- `lib/src/visitors/mod.rs` - Visitor module exports
- `lib/src/visitors/type_error_visitor.rs` - Type error extraction visitor
- `lib/src/visitors/symbol_visitor.rs` - Symbol extraction visitor
- `lib/src/visitors/dependency_visitor.rs` - Dependency tracking visitor

**Visitor implementations:**

Each visitor walks the OXC AST and collects relevant information:

```rust
// type_error_visitor.rs
pub struct TypeErrorVisitor<'a> {
    pub errors: Vec<TypeError>,
    pub source: &'a str,
    pub semantic: &'a Semantic<'a>,
}

impl<'a> Visit<'a> for TypeErrorVisitor<'a> {
    fn visit_ts_type_annotation(&mut self, annotation: &TSTypeAnnotation<'a>) {
        // Check for type errors using semantic.errors()
        // Extract scope context (function name, class::method)
        // Extract code block containing error
    }
}

// symbol_visitor.rs
pub struct SymbolVisitor<'a> {
    pub symbols: Vec<SymbolInfo>,
    pub exported_only: bool,
}

impl<'a> Visit<'a> for SymbolVisitor<'a> {
    fn visit_function(&mut self, func: &Function<'a>) {
        // Extract function info (name, params, return type)
        // Check if exported
    }

    fn visit_class(&mut self, class: &Class<'a>) {
        // Extract class info (name, methods, properties)
    }
}

// dependency_visitor.rs
pub struct DependencyVisitor<'a> {
    pub dependencies: Vec<String>,
    pub current_file: PathBuf,
}

impl<'a> Visit<'a> for DependencyVisitor<'a> {
    fn visit_import_declaration(&mut self, import: &ImportDeclaration<'a>) {
        // Extract import source
        // Classify as local/repo/external
    }
}
```

**Deliverables:**

- TypeErrorVisitor extracts errors from OXC semantic analysis
- SymbolVisitor finds all exported symbols with metadata
- DependencyVisitor tracks imports and their scopes

**Technical Details:**

- Use `oxc_ast::visit::Visit` trait
- Access `Semantic::symbols()` for symbol table
- Access `Semantic::errors()` for diagnostics
- Use `Span::source_text()` to extract code blocks
- Handle scope context by tracking current function/class during traversal

**Acceptance Criteria:**

- [ ] File `lib/src/visitors/mod.rs` exists
- [ ] File `lib/src/visitors/type_error_visitor.rs` exists (>150 lines)
- [ ] File `lib/src/visitors/symbol_visitor.rs` exists (>200 lines)
- [ ] File `lib/src/visitors/dependency_visitor.rs` exists (>150 lines)
- [ ] `grep "impl.*Visit.*for TypeErrorVisitor" lib/src/visitors/type_error_visitor.rs` succeeds
- [ ] `cargo test visitors::type_error_visitor` runs 8+ tests
- [ ] `cargo test visitors::symbol_visitor` runs 10+ tests
- [ ] `cargo test visitors::dependency_visitor` runs 6+ tests
- [ ] All tests pass with fixtures in `tests/fixtures/`

---

### Phase 4: Core Analyzers and Extractors

**Principal Owner:** Rust Developer

**Goal:** Implement analyzer modules that use visitors to extract information from TypeScript files

**Dependencies:** Phase 3 complete

**Blast Radius:** `cargo test --lib` (library tests)

**Files to create:**

- `lib/src/analyzer.rs` - Main coordinator for parallel analysis
- `lib/src/type_errors.rs` - Type error extractor
- `lib/src/symbols.rs` - Symbol extractor
- `lib/src/dependencies.rs` - Dependency extractor
- `lib/src/tests.rs` - Type test detector

**Analyzer structure:**

```rust
// analyzer.rs
pub struct Analyzer {
    allocator: Allocator,
    options: AnalysisOptions,
}

pub struct AnalysisOptions {
    pub include_patterns: Vec<String>,
    pub exclude_patterns: Vec<String>,
    pub parallel: bool,
    pub max_files: Option<usize>,
}

impl Analyzer {
    pub fn new(options: AnalysisOptions) -> Self;

    pub fn analyze_files(&self, files: &[PathBuf]) -> Result<AnalysisResult>;

    pub fn analyze_single_file(&self, file: &Path) -> Result<FileAnalysis>;
}

// Use Rayon for parallel processing
pub fn analyze_files_parallel(files: &[PathBuf]) -> Vec<FileAnalysis> {
    files.par_iter()
        .filter_map(|file| analyze_single_file(file).ok())
        .collect()
}
```

**Per-file analysis pipeline:**

1. Read file contents
2. Create OXC parser with allocator
3. Parse source → AST
4. Build semantic model
5. Run visitors (type errors, symbols, dependencies)
6. Return aggregated results

**Deliverables:**

- Analyzer coordinates parallel file processing
- Each extractor module uses appropriate visitor
- Error handling propagates parse/semantic errors
- Results aggregate into unified structures

**Technical Details:**

- Use `oxc_parser::Parser::new()` with allocator
- Parse with `parser.parse()`
- Build semantic with `SemanticBuilder::new().build()`
- Reuse allocator per thread (not across threads)
- Use Rayon's `par_iter()` for parallel file processing
- Handle parse errors gracefully (log and continue)

**Acceptance Criteria:**

- [ ] File `lib/src/analyzer.rs` exists (>200 lines)
- [ ] File `lib/src/type_errors.rs` exists (>150 lines)
- [ ] File `lib/src/symbols.rs` exists (>180 lines)
- [ ] File `lib/src/dependencies.rs` exists (>170 lines)
- [ ] File `lib/src/tests.rs` exists (>160 lines)
- [ ] `grep "pub struct Analyzer" lib/src/analyzer.rs` succeeds
- [ ] `grep "Rayon" lib/Cargo.toml` succeeds (dependency present)
- [ ] `cargo test analyzer` runs 10+ tests
- [ ] `cargo test type_errors` runs 8+ tests
- [ ] `cargo test symbols` runs 12+ tests
- [ ] All tests pass with test fixtures covering happy paths and error cases

---

### Phase 5: File Watching System

**Principal Owner:** Rust Developer

**Goal:** Implement file watching with event detection and handler dispatch

**Dependencies:** Phase 4 complete

**Blast Radius:** `cargo test --lib` (watcher integrates with analyzer infrastructure)

**Files to create:**

- `lib/src/watcher.rs` - File watching and event system

**Watcher implementation:**

```rust
pub enum WatchEvent {
    SourceFileChanged { file: String, content: String },
    SourceFileCreated { file: String },
    SourceFileRemoved { file: String },
    SymbolRenamed { old_name: String, new_name: String, file: String },
    SymbolAdded { name: String, kind: SymbolKind, file: String },
    SymbolRemoved { name: String, file: String },
    ModuleDepChanged { file: String },
    ExternalDepChanged { package: String },
    TestStatusChanged { file: String, test: String, status: TestStatus },
    NewFailingTest { file: String, test: String },
    TestFixed { file: String, test: String },
    NewTestAdded { file: String, test: String },
}

pub trait WatchHandler: Send + Sync {
    fn handle_event(&self, event: &WatchEvent) -> Result<()>;
}

pub struct FileWatcher {
    analyzer: Analyzer,
    handlers: Vec<Box<dyn WatchHandler>>,
}

impl FileWatcher {
    pub fn watch(&self, paths: &[PathBuf]) -> Result<()> {
        // Use notify crate to watch filesystem
        // Detect changes and generate events
        // Call handlers for each event
    }
}
```

**Event detection logic:**

- File changed → Re-analyze → Compare symbols → Generate symbol events
- Test file changed → Re-run type test detection → Compare results → Generate test events
- Dependency changed → Compare import statements → Generate dependency events

**Deliverables:**

- FileWatcher monitors filesystem using notify crate
- Events are generated based on diff analysis
- Handlers can be executable scripts or TypeScript functions

**Technical Details:**

- Use `notify::Watcher` with recursive mode
- Debounce events using `notify::Config::default().with_poll_interval(Duration::from_millis(500))`
- Store previous analysis state to detect diffs
- Execute handlers via `std::process::Command`
- Validate handler file exists before execution
- On POSIX systems, check executable bit with `std::fs::metadata().permissions().mode() & 0o111`
- For TypeScript handlers, check for `bun` binary and execute with `bun run handler.ts`
- Handle missing `bun` gracefully with clear error message
- Pass event data as JSON via stdin to handlers

**Acceptance Criteria:**

- [ ] File `lib/src/watcher.rs` exists (>300 lines)
- [ ] `grep "notify" lib/Cargo.toml` succeeds (dependency present)
- [ ] `grep "pub enum WatchEvent" lib/src/watcher.rs` succeeds
- [ ] Handler execution validates file exists before running
- [ ] On POSIX systems, checks executable bit before execution
- [ ] Gracefully handles missing `bun` with clear error message
- [ ] `cargo test watcher` runs 15+ tests including invalid handler scenarios
- [ ] Tests cover all 12 event types
- [ ] Tests verify handler execution and validation
- [ ] Tests use tempfile for isolated test directories
- [ ] All tests pass

---

### Phase 6: CLI Command Structure with Clap

**Principal Owner:** Rust Developer

**Goal:** Implement complete CLI with all 6 subcommands using clap derive API

**Dependencies:** Phases 4 and 5 complete

**Blast Radius:** `cargo test` (full suite to catch CLI and library integration issues)

**Files to create:**

- `cli/src/commands/mod.rs` - Command module exports
- `cli/src/commands/source.rs` - Source command implementation
- `cli/src/commands/symbols.rs` - Symbols command implementation
- `cli/src/commands/test.rs` - Test command implementation
- `cli/src/commands/file.rs` - File command implementation
- `cli/src/commands/deps.rs` - Deps command implementation
- `cli/src/commands/watch.rs` - Watch command implementation

**Files to modify:**

- `cli/src/main.rs` - Complete clap structure with all subcommands

**CLI structure:**

```rust
// main.rs
#[derive(Parser)]
#[command(name = "ta")]
#[command(about = "TypeScript Analyzer - High-performance AST analysis")]
#[command(version, long_about = None)]
pub struct Cli {
    #[arg(short, long, value_enum, default_value = "console")]
    pub format: OutputFormat,

    #[arg(short, long)]
    pub verbose: bool,

    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    Source(SourceArgs),
    Symbols(SymbolsArgs),
    Test(TestArgs),
    File(FileArgs),
    Deps(DepsArgs),
    Watch(WatchArgs),
}

// Each command args struct in commands/*.rs
#[derive(Parser)]
pub struct SourceArgs {
    #[arg(value_name = "FILTER")]
    pub filter: String,

    #[arg(long)]
    pub include_tests: bool,

    #[arg(long, default_value = "100")]
    pub max_errors: usize,

    // ... other args per design doc
}
```

**Each command implementation:**

1. Parse args via clap
2. Set up env_logger based on verbose flag
3. Call appropriate library function
4. Format output based on --format flag
5. Write to stdout (data) and stderr (progress)
6. Handle errors with color-eyre

**Deliverables:**

- Complete CLI with all 6 subcommands
- Help text for all commands
- Output format switching works
- Logging to stderr works

**Technical Details:**

- Use clap's derive API with `#[derive(Parser)]`
- Use `#[command]` attributes for metadata
- Use `#[arg]` for argument configuration
- Initialize `color_eyre` in main with `color_eyre::install()?`
- Initialize `env_logger` with `env_logger::Builder::from_default_env().init()`
- Use `eprintln!` for status messages, `println!` for data output
- Return `color_eyre::Result<()>` from main
- Validate glob patterns in source and file commands to prevent path traversal (no ".." allowed)
- Validate glob compiles with `glob::Pattern::new()`

**Acceptance Criteria:**

- [ ] File `cli/src/commands/mod.rs` exists
- [ ] Files exist: `cli/src/commands/{source,symbols,test,file,deps,watch}.rs` (6 files)
- [ ] File `cli/src/main.rs` has complete clap structure (>100 lines)
- [ ] `grep "#\[derive(Parser)\]" cli/src/main.rs` succeeds
- [ ] `cargo run -p cli -- --help` shows all 6 subcommands
- [ ] `cargo run -p cli -- source --help` shows source command help
- [ ] `cargo run -p cli -- symbols --help` shows symbols command help
- [ ] Each command file has >80 lines
- [ ] Integration tests exist in `tests/` directory with 30+ tests total
- [ ] `cargo test --bin ta` runs all integration tests
- [ ] All tests pass

---

### Phase 7: Integration Testing and Fixtures

**Principal Owner:** Feature Tester (Rust)

**Goal:** Create comprehensive test suite with fixtures and integration tests

**Dependencies:** Phase 6 complete

**Blast Radius:** `cargo test` (full suite)

**Files to create:**

- `tests/integration_test.rs` - Integration tests for CLI commands
- `tests/common/mod.rs` - Shared test utilities
- `tests/fixtures/` - Sample TypeScript files for testing
    - `tests/fixtures/simple.ts` - Valid TypeScript with no errors
    - `tests/fixtures/with-errors.ts` - TypeScript with type errors
    - `tests/fixtures/exports.ts` - File with various exported symbols
    - `tests/fixtures/dependencies.ts` - File with imports
    - `tests/fixtures/test-file.test.ts` - Sample test file with type tests

**Test coverage:**

**Unit tests** (in lib/src modules):

- `lib/src/models.rs` - Serialization, deserialization
- `lib/src/output.rs` - Format conversions
- `lib/src/colorize.rs` - ANSI and HTML generation
- `lib/src/visitors/*.rs` - Visitor behavior with sample AST nodes
- `lib/src/analyzer.rs` - Analysis coordination
- Each extractor module - Extraction logic

**Integration tests** (in tests/):

- CLI command parsing
- End-to-end analysis workflows
- Output format validation
- Error handling
- File watching behavior

**Property-based tests** (using proptest):

- TypeScript parsing roundtrips
- JSON serialization roundtrips
- ANSI escape code validity

**Deliverables:**

- 100+ total tests across unit and integration
- Test fixtures cover all major scenarios
- Property-based tests for invariants
- CI-ready test suite

**Technical Details:**

- Use `#[cfg(test)] mod tests` in library modules
- Use `tests/` directory for integration tests
- Use `assert_cmd` crate for CLI testing
- Use `predicates` crate for assertions
- Use `tempfile` for temporary test directories
- Create realistic TypeScript fixtures
- Use snapshot testing for HTML/Console output

**Acceptance Criteria:**

- [ ] Directory `tests/fixtures/` exists with 5+ TypeScript files
- [ ] File `tests/integration_test.rs` exists (>400 lines)
- [ ] File `tests/common/mod.rs` exists with test utilities (>100 lines)
- [ ] `find lib/src -name "*.rs" -exec grep -l "#\[cfg(test)\]" {} \; | wc -l` shows 10+ files
- [ ] `cargo test --lib` runs 80+ unit tests
- [ ] `cargo test --test integration_test` runs 30+ integration tests
- [ ] `cargo test` runs 100+ total tests
- [ ] `cargo test` passes with zero failures
- [ ] Test coverage includes all 6 CLI subcommands
- [ ] Test fixtures are valid TypeScript (verified manually or with tsc)

---

### Phase 8: TypeScript Handler Types (Optional)

**Principal Owner:** Rust Developer

**Goal:** Create TypeScript type definitions for watch event handlers

**Dependencies:** Phase 5 complete

**Blast Radius:** `pnpm test` in `/ts` directory (no Rust tests affected)

**Files to modify:**

- `ts/index.ts` - Export handler type definitions

**Type definitions:**

```typescript
// Event types matching Rust WatchEvent enum
export type WatchEvent =
  | SourceFileChangedEvent
  | SourceFileCreatedEvent
  | SourceFileRemovedEvent
  | SymbolRenamedEvent
  | SymbolAddedEvent
  | SymbolRemovedEvent
  | ModuleDepChangedEvent
  | ExternalDepChangedEvent
  | TestStatusChangedEvent
  | NewFailingTestEvent
  | TestFixedEvent
  | NewTestAddedEvent;

export interface SourceFileChangedEvent {
  type: 'SourceFileChanged';
  file: string;
  content: string;
}

// ... other event interfaces

// Handler function types
export type SourceFileChangedHandler = (event: SourceFileChangedEvent) => void | Promise<void>;
export type SymbolAddedHandler = (event: SymbolAddedEvent) => void | Promise<void>;
// ... other handler types
```

**Deliverables:**

- Complete TypeScript type definitions
- JSDoc documentation for all types
- Built declarations file (.d.ts)

**Technical Details:**

- Export all event types
- Export handler function types
- Use union types for WatchEvent
- Match Rust serialization format exactly
- Build with `pnpm build` (tsdown configured)

**Acceptance Criteria:**

- [ ] File `ts/index.ts` exists with type definitions (>150 lines)
- [ ] `grep "export type WatchEvent" ts/index.ts` succeeds
- [ ] `grep "Handler" ts/index.ts | wc -l` shows 12+ handler types
- [ ] `cd ts && pnpm build` succeeds
- [ ] File `ts/dist/index.d.ts` exists
- [ ] TypeScript compilation produces zero errors

---

## Cross-Cutting Concerns

### Testing Strategy

**Unit Tests:**

- Located in `#[cfg(test)] mod tests` blocks within each module
- Test individual functions and struct methods
- Use test fixtures for sample TypeScript code
- Mock external dependencies where needed

**Integration Tests:**

- Located in `tests/` directory
- Test CLI commands end-to-end
- Use `assert_cmd` for process testing
- Verify stdout/stderr output
- Test all three output formats

**Property-Based Tests:**

- Use `proptest` for invariant testing
- Test TypeScript parsing roundtrips
- Test JSON serialization/deserialization
- Test ANSI escape code validity

**Test Organization:**

```
lib/src/
  analyzer.rs
    #[cfg(test)]
    mod tests { ... }

tests/
  integration_test.rs
  common/
    mod.rs
  fixtures/
    simple.ts
    with-errors.ts
    ...
```

### Security Considerations

**File System Safety:**

- Validate glob patterns to prevent path traversal
- Limit file reading to specified patterns
- Handle symlinks carefully in file watching

**Command Execution:**

- Validate handler executables in watch mode
- Use `std::process::Command` safely
- Avoid shell injection when executing handlers
- Limit handler execution timeout

**Input Validation:**

- Sanitize user-provided file paths
- Validate regex patterns for filtering
- Limit maximum file sizes for parsing

### Performance Considerations

**Parallel Processing:**

- Use Rayon for multi-core file analysis
- Process files in parallel by default
- Thread-local allocators for OXC parsing
- Minimize shared state between threads

**Memory Management:**

- Use OXC arena allocation for AST nodes
- Avoid unnecessary string clones
- Stream large outputs instead of buffering
- Reuse allocators within threads

**Optimization Targets:**

- Parse 1000+ TypeScript files in under 10 seconds (on modern hardware)
- Minimal allocations in hot paths (AST traversal)
- Efficient ANSI escape code generation
- Fast JSON serialization with serde

**Profiling:**

- Use `cargo bench` for benchmarking
- Profile with `cargo flamegraph` or `perf`
- Monitor memory usage with valgrind/heaptrack
- Benchmark against real-world TypeScript repos

### OXC Integration Patterns

**Parser Setup:**

```rust
use oxc_allocator::Allocator;
use oxc_parser::Parser;
use oxc_semantic::SemanticBuilder;
use oxc_span::SourceType;

let allocator = Allocator::default();
let source_type = SourceType::from_path(&file_path).unwrap();
let parser = Parser::new(&allocator, &source_code, source_type);
let parse_result = parser.parse();

if !parse_result.errors.is_empty() {
    // Handle parse errors
}

let semantic = SemanticBuilder::new(&source_code)
    .build(&parse_result.program)
    .semantic;
```

**Custom Visitor Pattern:**

```rust
use oxc_ast::visit::Visit;

struct MyVisitor {
    results: Vec<String>,
}

impl<'a> Visit<'a> for MyVisitor {
    fn visit_function(&mut self, func: &Function<'a>) {
        // Extract function information
        self.results.push(func.name.clone());
        // Continue walking
        walk::walk_function(self, func);
    }
}
```

**Scope Context Tracking:**

```rust
// Track current scope for error context
struct ScopeTracker {
    current_function: Option<String>,
    current_class: Option<String>,
}

impl ScopeTracker {
    fn scope_string(&self) -> String {
        match (&self.current_class, &self.current_function) {
            (Some(class), Some(method)) => format!("{}::{}", class, method),
            (None, Some(func)) => func.clone(),
            _ => "root".to_string(),
        }
    }
}
```

### Error Handling

**Library Errors (thiserror):**

```rust
#[derive(Debug, thiserror::Error)]
pub enum AnalysisError {
    #[error("Parse error in {file}: {message}")]
    ParseError { file: String, message: String },

    #[error("Semantic analysis failed: {0}")]
    SemanticError(String),

    #[error("I/O error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Invalid source type for {0}")]
    InvalidSourceType(String),
}
```

**CLI Errors (color-eyre):**

```rust
// In main.rs
fn main() -> color_eyre::Result<()> {
    color_eyre::install()?;

    // CLI logic

    Ok(())
}

// Detailed error context
fn analyze_files(paths: &[PathBuf]) -> color_eyre::Result<Analysis> {
    let result = lib::analyze(paths)
        .wrap_err("Failed to analyze TypeScript files")?;
    Ok(result)
}
```

### Logging and Observability

**Library Logging:**

```rust
use log::{debug, info, warn, error};

pub fn analyze_file(path: &Path) -> Result<FileAnalysis> {
    info!("Analyzing file: {}", path.display());

    let content = std::fs::read_to_string(path)
        .map_err(|e| {
            error!("Failed to read {}: {}", path.display(), e);
            e
        })?;

    debug!("File size: {} bytes", content.len());

    // Analysis logic

    Ok(result)
}
```

**CLI Logging Configuration:**

```rust
// In main.rs
fn setup_logging(verbose: bool) {
    let log_level = if verbose { "debug" } else { "info" };

    env_logger::Builder::from_env(
        env_logger::Env::default().default_filter_or(log_level)
    )
    .format_timestamp(None)
    .format_target(false)
    .init();
}
```

**Status Messages:**

```rust
// Progress to stderr
eprintln!("Analyzing {} files...", file_count);

// Data to stdout
println!("{}", serde_json::to_string_pretty(&result)?);
```

## Parallelization Opportunities

### Parallel Execution Groups

| Group | Phases | Can Start After | Assignees |
|-------|--------|-----------------|-----------|
| A | 1, 2 | Plan approval | Rust Developer |
| B | 3 | Phase 2 complete | Rust Developer |
| C | 4, 5 | Phase 3 complete | Rust Developer (Phase 4), Rust Developer (Phase 5) |
| D | 6 | Phase 4 complete | Rust Developer |
| E | 7, 8 | Phase 6 complete | Feature Tester (Phase 7), Rust Developer (Phase 8) |

### Parallelization Diagram

```text
Timeline:
─────────────────────────────────────────────────────────►

Phase 1: ████████
             │
Phase 2:     └──████████
                       │
Phase 3:               └──████████████
                                    │
Phase 4:                            └──████████████
Phase 5:                            └──████████████ (parallel with 4)
                                                  │
Phase 6:                                          └──████████
                                                            │
Phase 7:                                                    └──████████
Phase 8:                                                    └──████████ (parallel with 7)
```

### Synchronization Points

1. **After Phase 1:** Workspace and dependencies must be configured
2. **After Phase 2:** Data models must be finalized (used by all subsequent phases)
3. **After Phase 3:** AST visitors must be complete (used by extractors)
4. **After Phases 4 & 5:** All library functionality must be complete (used by CLI)
5. **After Phase 6:** CLI must be functional (tested by integration tests)

**Note on Phases 4 & 5:** These can run in parallel as they're independent:

- Phase 4: Core analyzers (type errors, symbols, dependencies, tests)
- Phase 5: File watcher (independent of analyzers, uses same visitor infrastructure)

**Note on Phases 7 & 8:** These can run in parallel:

- Phase 7: Integration testing (tests the Rust implementation)
- Phase 8: TypeScript types (independent, optional feature)

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| OXC API instability (0.31 is recent) | High | Pin exact version, monitor releases, isolate OXC usage behind abstraction layer |
| Parallel processing complexity | Medium | Start with sequential implementation, add parallelism incrementally, comprehensive testing |
| File watching edge cases (rapid changes, large repos) | Medium | Implement debouncing, test with large repos, handle errors gracefully |
| TypeScript syntax edge cases | Medium | Extensive test fixtures, fallback to best-effort parsing, detailed error reporting |
| Cross-platform compatibility (Windows paths, etc.) | Low | Use std::path, test on all platforms in CI, handle path separators correctly |
| Performance on large codebases (10k+ files) | Medium | Profile early, optimize hot paths, implement caching if needed, stream results |
| Memory usage with large files | Low | Use streaming where possible, limit max file size, arena allocation helps |
| CLI argument complexity | Low | Follow clap best practices, comprehensive help text, validation in arg parsing |

## Review Summary

**Reviews Completed:** 2025-12-20

**Reviewers:**
- **Rust Developer:** Approve with Changes
- **Feature Tester (Rust):** Approve with Changes

**Key Changes from Review:**

1. **Corrected OXC version** from 0.31 to 0.30 (actual latest stable)
2. **Fixed Rust edition** to 2021 (2024 doesn't exist)
3. **Added test dependencies** to Cargo.toml files (proptest, insta, assert_cmd, predicates, tempfile)
4. **Enhanced Phase 5 (Watcher)** with explicit debouncing implementation and handler validation
5. **Added glob pattern validation** to prevent path traversal attacks
6. **Expanded Phase 5 blast radius** from focused watcher tests to full library tests
7. **Enhanced Phase 6 blast radius** to run full test suite instead of just CLI tests
8. **Added security validations** for file handlers (executable bit check, file existence)
9. **Specified cargo-nextest** as recommended development tool for faster test execution

**Resolved Concerns:**

- **Version specifications** → Fixed OXC to 0.30 and Rust edition to 2021
- **Missing test dependencies** → Added all required dev-dependencies to both lib and CLI
- **Security validation gaps** → Added explicit glob pattern validation and handler file validation
- **Debouncing implementation** → Specified using notify's built-in `with_poll_interval()` configuration
- **Error handling in parallel processing** → Plan shows using `par_iter().filter_map()` with logging
- **Blast radius accuracy** → Adjusted Phases 5 and 6 for broader coverage

**Outstanding Recommendations (Optional):**

- Add CI/CD pipeline configuration (consider as Phase 9 or post-MVP)
- Add benchmarking infrastructure with Criterion (consider adding to Phase 7)
- Add release profile optimizations to workspace Cargo.toml (mentioned in technical details)
- Consider snapshot testing with insta for output validation (mentioned in Phase 7)

## Open Questions

- [ ] Should we implement caching for parsed ASTs to speed up repeated analysis?
- [ ] What's the maximum file size we should support (to prevent OOM)?
- [ ] Should watch mode persist state between runs (for better diff detection)?
- [ ] Do we need custom colorization rules beyond basic TypeScript syntax?
- [ ] Should we support configuration files (.ta.toml) or just CLI args?
- [ ] What's the priority for Windows support (all contributors on macOS/Linux currently)?
- [ ] Should we implement progress bars for long-running operations (needs `indicatif` crate)?
- [ ] Do we want to support multiple test frameworks or just detect common patterns?
- [ ] Should HTML output include inline CSS or require external stylesheet?
- [ ] What's the strategy for handling very large monorepos (10k+ files)?

---

## Implementation Notes

**Ready for execution with `/execute-phase` or manual implementation.**

**Critical Success Factors:**
1. Use OXC 0.30 (not 0.31 which doesn't exist)
2. Set Rust edition to 2021 in workspace
3. Include all test dependencies from day one
4. Implement security validations (glob patterns, handler files)
5. Test comprehensively at each phase boundary

**Recommended Tools:**
- `cargo nextest run` for faster test execution
- `cargo clippy` for linting
- `cargo watch` for development workflow
- `insta` for snapshot testing of output formats
