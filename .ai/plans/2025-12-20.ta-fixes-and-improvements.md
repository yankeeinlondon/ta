# TA CLI Fixes and Improvements

**Created:** 2025-12-20
**Status:** Reviewed - Ready for Implementation

## Review Summary

**Reviews Completed:** 2025-12-20

**Reviewers:**
- Rust Developer: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Key Changes from Review and User Requests:**
1. **Added Phase 0**: Critical `--dir/-d` global switch for monorepo support (user request)
2. **Enhanced Phase 1**: Glob pattern normalization with auto-wildcard expansion (user request)
3. **Enhanced Phase 1**: Improved test command base patterns and .gitignore support (user request)
4. Enhanced security: Path traversal check now uses canonicalization
5. Simplified Phase 2: Just add `global = true` attributes (not a refactor)
6. Improved test file filtering: Use `.ends_with()` instead of `.contains()`
7. Enhanced Phase 6: More specific test scenarios and edge cases (now 67+ tests total)
8. Added NO_COLOR environment variable support
9. Improved error code extraction approach investigation

**Resolved Concerns:**
- Path traversal security → Enhanced with canonicalization check
- Error code extraction brittleness → Added investigation step for OXC API
- Test coverage depth → Enhanced Phase 6 with specific edge cases
- Colorization testing → Added specific ANSI code verification
- Filter usability → Auto-wildcard expansion makes filtering intuitive
- Test discovery → Comprehensive base patterns + .gitignore support

## Executive Summary

This plan addresses critical bugs and usability issues identified through user testing and code review. The focus is on:

1. **Monorepo Support** (NEW): Add `--dir/-d` global switch to run from any directory
2. **Glob Pattern Filtering** (NEW): Auto-wildcard expansion for intuitive filtering (e.g., `ta test foobar` → `*foobar*`)
3. **Improved Test Command** (NEW): Better base glob patterns and .gitignore support for comprehensive test discovery
4. **Broken Functionality**: Fix format flags, filtering, error metadata
5. **Security**: Prevent path traversal with glob validation and canonicalization
6. **Usability**: Simpler filtering, negative patterns, better error messages
7. **Colorization**: Add ANSI colors to console output, HTML semantic classes

**Critical Additions:**
- **Phase 0**: `--dir` flag for monorepo support (`ta --dir packages/frontend source`)
- **Phase 1**: Glob pattern normalization with auto-wildcard expansion (`ta test foobar` finds test files with *foobar* in path)
- **Phase 1**: Improved test command with patterns: `!node_modules`, `dist/**/*`, `src/**/*.{test,spec}.{ts,tsx}`, `{test,tests}/**/*.{ts,tsx}`, plus .gitignore exclusions

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-0 | Add global `--dir/-d` switch to set working directory | Critical | Rust Developer |
| FR-1 | Replace `--format/-f` with `--json` and `--html` boolean flags | High | Rust Developer |
| FR-2 | Make PATTERN positional argument for filtering (remove `-n/--name` requirement) | High | Rust Developer |
| FR-2a | Treat PATTERN as glob pattern with auto-wildcard expansion | High | Rust Developer |
| FR-2b | Improve `test` command base glob patterns and add .gitignore support | High | Rust Developer |
| FR-3 | Add negative filter support with `!` prefix (e.g., `ta symbols '!Watch'`) | High | Rust Developer |
| FR-4 | Fix global scope switches (`--verbose`, `--format`) to work at command level | High | Rust Developer |
| FR-5 | Implement console colorization using `colored` crate | High | Rust Developer |
| FR-6 | Fix TypeError.file field to show actual file path | High | Rust Developer |
| FR-7 | Fix TypeError.id field to parse actual error codes from OXC diagnostics | High | Rust Developer |
| FR-8 | Implement `--include-tests` filter logic | High | Rust Developer |
| FR-9 | Add glob pattern validation to prevent path traversal (`..`) | High | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | All existing tests must pass | 26/26 tests | Feature Tester |
| NFR-2 | No new clippy warnings introduced | 0 new warnings | Rust Developer |
| NFR-3 | Colorization must match design doc specification | Consistent color scheme | Rust Developer |
| NFR-4 | Changes must not break existing CLI usage patterns | Backward compatible where possible | Rust Developer |

## Architecture Overview

The fixes span multiple layers of the architecture:

1. **CLI Layer** (`cli/src/main.rs`, `cli/src/commands/*.rs`)
   - Clap argument structure changes (format flags, positional patterns)
   - Global option propagation fixes

2. **Library Layer** (`lib/src/`)
   - TypeErrorVisitor: file path propagation, error ID parsing
   - OutputFormatter: colorization implementation
   - Analyzer: test file filtering

3. **Testing Layer** (`tests/`)
   - New tests for negative filtering, colorization, security validation

### Data Flow Impact

```
User Input
    ↓
CLI Parsing (clap) ← PHASE 0: Add --dir switch
    ↓
Working Directory ← PHASE 0: Change to specified directory
    ↓
CLI Parsing (clap) ← PHASE 1: Fix format flags, positional args
    ↓
Command Handlers ← PHASE 2: Fix global option propagation
    ↓
Analyzer ← PHASE 3: Fix include-tests, glob validation
    ↓
Visitors ← PHASE 4: Fix TypeError.file, TypeError.id
    ↓
OutputFormatter ← PHASE 5: Add colorization
    ↓
Console/JSON/HTML Output
```

## Phases

### Phase 0: Add Global Directory Switch (CRITICAL)

**Principal Owner:** Rust Developer

**Goal:** Add `--dir/-d` global flag to change working directory before executing commands

**Dependencies:** None (foundational - must be first)

**Blast Radius:** `cargo test` (affects all commands and tests)

**Files to modify:**
- `cli/src/main.rs` - Add `--dir/-d` flag to Cli struct, change directory early in main()
- `tests/integration/cli_test.rs` - Add tests for directory switching

**Technical Details:**

This is critical for monorepos where the TypeScript project may not be at the root, and essential for testing.

```rust
// cli/src/main.rs
#[derive(Parser)]
#[command(name = "ta")]
#[command(about = "TypeScript Analyzer - High-performance AST analysis")]
#[command(version, long_about = None)]
pub struct Cli {
    /// Change to this directory before executing command
    #[arg(short, long, global = true, value_name = "PATH")]
    pub dir: Option<PathBuf>,

    // ... rest of fields
}

fn main() -> Result<()> {
    color_eyre::install()?;

    let cli = Cli::parse();

    // Change directory BEFORE doing anything else
    if let Some(dir) = &cli.dir {
        std::env::set_current_dir(dir)
            .wrap_err_with(|| format!("Failed to change to directory: {}", dir.display()))
            .with_help("Ensure the directory exists and you have permissions")?;
    }

    setup_logging(cli.verbose);
    setup_colors();

    // ... rest of main
}
```

**Usage Examples:**

```bash
# Analyze TypeScript in a subdirectory
ta --dir packages/frontend source

# Works with all commands
ta -d my-project symbols
ta --dir ~/code/monorepo/app test

# Critical for testing
cargo test -- --test-args "--dir fixtures"
```

**Why This is Critical:**

1. **Monorepo Support**: In monorepos, TypeScript projects are often in subdirectories
   - `packages/frontend/`, `apps/web/`, etc.
   - Without `--dir`, users must `cd` first (breaks scripting)

2. **Testing**: Makes integration tests much simpler
   - Can run tests from project root with `--dir tests/fixtures`
   - No need to copy fixtures to working directory

3. **CI/CD**: Enables clean CI scripts
   - `ta --dir $PROJECT_PATH source` instead of `cd $PROJECT_PATH && ta source`

4. **Consistency**: Matches common CLI tools
   - `git -C path`, `npm --prefix path`, `cargo --manifest-path path`

**Acceptance Criteria:**
- [ ] File `cli/src/main.rs` modified with `dir: Option<PathBuf>` field
- [ ] `std::env::set_current_dir()` called early in main() if `--dir` provided
- [ ] Error message with helpful context if directory doesn't exist
- [ ] `ta --dir packages/frontend source` changes to that directory
- [ ] `ta -d my-app symbols` works (short form)
- [ ] All relative paths in patterns work relative to new directory
- [ ] `ta --dir nonexistent source` returns clear error
- [ ] Integration test: `test_dir_flag_changes_working_directory`
- [ ] Integration test: `test_dir_flag_nonexistent_error`
- [ ] Integration test: `test_dir_flag_with_relative_patterns`
- [ ] All existing tests still pass (no regression)
- [ ] `cargo test` passes

---

### Phase 1: CLI Argument Structure Changes

**Principal Owner:** Rust Developer

**Goal:** Replace `--format/-f` with `--json` and `--html` flags, make filter patterns positional with glob wildcard expansion, add negative filter support, improve test command glob patterns

**Dependencies:** None

**Blast Radius:** `cargo test --bin ta` (CLI tests)

**Files to modify:**
- `cli/src/main.rs` - Change Cli struct format argument
- `cli/src/commands/symbols.rs` - Make pattern positional, remove `-n/--name`, add glob normalization
- `cli/src/commands/source.rs` - Add negative filter logic, glob normalization
- `cli/src/commands/test.rs` - Update pattern handling, improve base glob patterns, add .gitignore support
- `cli/src/commands/file.rs` - Update pattern handling, glob normalization
- `cli/src/commands/deps.rs` - Update pattern handling, glob normalization
- `cli/src/utils.rs` (new) - Shared glob normalization and .gitignore parsing utilities

**Technical Details:**

1. **Format Flag Changes:**
```rust
// OLD (main.rs:20-22)
#[arg(short, long, value_enum, default_value = "console")]
pub format: OutputFormat,

// NEW
/// Output as JSON instead of console format
#[arg(long)]
pub json: bool,

/// Output as HTML instead of console format
#[arg(long)]
pub html: bool,

// Derive OutputFormat in main():
let format = if cli.json {
    OutputFormat::Json
} else if cli.html {
    OutputFormat::Html
} else {
    OutputFormat::Console
};
```

2. **Positional Pattern with Optional Negative Filter:**
```rust
// symbols.rs - OLD (line 10-19)
pub pattern: String,
#[arg(short, long)]
pub name: Option<String>,

// NEW
/// Optional pattern to filter symbols (prefix with ! for negative match)
#[arg(value_name = "PATTERN")]
pub pattern: Option<String>,
```

3. **Glob Pattern Normalization with Auto-Wildcard Expansion:**

Filters should be treated as glob patterns that get added to base glob patterns. Auto-expand wildcards if the user's pattern doesn't already contain glob syntax at the start/end.

```rust
// cli/src/utils.rs (NEW FILE)

/// Normalize a user-provided pattern by adding wildcards if not already glob-like
pub fn normalize_glob_pattern(pattern: &str) -> String {
    let has_glob_start = pattern.starts_with('*') ||
                         pattern.starts_with('?') ||
                         pattern.starts_with('[') ||
                         pattern.starts_with('{');

    let has_glob_end = pattern.ends_with('*') ||
                       pattern.ends_with('?') ||
                       pattern.ends_with(']') ||
                       pattern.ends_with('}');

    match (has_glob_start, has_glob_end) {
        (true, true) => pattern.to_string(),         // Already has wildcards both ends
        (true, false) => format!("{}*", pattern),    // Add wildcard at end
        (false, true) => format!("*{}", pattern),    // Add wildcard at start
        (false, false) => format!("*{}*", pattern),  // Add wildcards both ends
    }
}

/// Example usage:
/// - User types: `foobar` → normalized to `*foobar*`
/// - User types: `src/**/*.ts` → unchanged (already has glob syntax)
/// - User types: `*.ts` → normalized to `*.ts*` (adds end wildcard)
```

**Usage in commands:**

```rust
// In handle_test(), handle_symbols(), etc.:
if let Some(pattern) = args.pattern {
    let normalized = normalize_glob_pattern(&pattern);

    // Apply to base glob patterns
    let mut patterns = base_glob_patterns();  // e.g., ["src/**/*.ts"]
    patterns.push(normalized);  // Add user's filter pattern

    // Use patterns for file resolution
    for pattern in &patterns {
        for entry in glob::glob(pattern)? {
            // ...
        }
    }
}
```

**Common Example:**
```bash
# User wants to test only files in "foobar" subdirectory
ta test foobar

# Internally becomes: *foobar*
# Applied to base patterns: src/**/*.test.ts + *foobar* filter
# Result: Only test files with "foobar" in their path
```

4. **Improved Base Glob Patterns for Test Command:**

The `test` command currently has inadequate default glob patterns. Replace with comprehensive patterns and .gitignore support.

```rust
// cli/src/commands/test.rs

fn default_test_glob_patterns() -> Vec<String> {
    vec![
        "!node_modules/**/*".to_string(),        // Exclude node_modules
        "dist/**/*".to_string(),                 // Include dist (for monorepos that test built code)
        "src/**/*.{test,spec}.{ts,tsx}".to_string(),  // Standard src/ test files
        "{test,tests}/**/*.{ts,tsx}".to_string(),     // Dedicated test directories
    ]
}

/// Parse .gitignore file and convert patterns to glob exclude patterns
fn parse_gitignore_patterns() -> Result<Vec<String>> {
    let gitignore_path = Path::new(".gitignore");

    if !gitignore_path.exists() {
        return Ok(Vec::new());
    }

    let content = std::fs::read_to_string(gitignore_path)
        .wrap_err("Failed to read .gitignore")?;

    let patterns: Vec<String> = content
        .lines()
        .filter(|line| !line.trim().is_empty() && !line.starts_with('#'))
        .map(|line| {
            let trimmed = line.trim();
            // Convert .gitignore pattern to glob exclude pattern
            if trimmed.starts_with('!') {
                // Negated pattern in .gitignore - skip or handle specially
                return None;
            }
            Some(format!("!{}/**/*", trimmed.trim_end_matches('/')))
        })
        .flatten()
        .collect();

    Ok(patterns)
}

pub fn handle_test(args: TestArgs, format: OutputFormat) -> Result<()> {
    // Start with default patterns
    let mut patterns = default_test_glob_patterns();

    // Add .gitignore exclusions
    let gitignore_patterns = parse_gitignore_patterns()?;
    patterns.extend(gitignore_patterns);

    // Add user's filter if provided
    if let Some(filter) = args.pattern {
        let normalized = normalize_glob_pattern(&filter);
        patterns.push(normalized);
    }

    // Resolve all patterns to files
    let mut files = Vec::new();
    for pattern in &patterns {
        if pattern.starts_with('!') {
            // Exclude pattern - handle separately
            continue;
        }

        for entry in glob::glob(pattern)? {
            let path = entry?;
            if path.is_file() {
                files.push(path);
            }
        }
    }

    // Apply exclusion patterns
    let exclude_patterns: Vec<&str> = patterns
        .iter()
        .filter(|p| p.starts_with('!'))
        .map(|p| p.trim_start_matches('!'))
        .collect();

    for exclude in exclude_patterns {
        files.retain(|f| {
            !glob::Pattern::new(exclude)
                .unwrap()
                .matches(f.to_str().unwrap())
        });
    }

    // ... rest of test command
}
```

**Alternative: Use `ignore` crate for .gitignore parsing**

Instead of manual parsing, use the `ignore` crate which properly handles .gitignore syntax:

```toml
# cli/Cargo.toml
[dependencies]
ignore = "0.4"
```

```rust
use ignore::WalkBuilder;

pub fn handle_test(args: TestArgs, format: OutputFormat) -> Result<()> {
    let walker = WalkBuilder::new(".")
        .standard_filters(true)  // Respects .gitignore, .ignore, etc.
        .types(Types::new().add("test", "*.{test,spec}.{ts,tsx}").unwrap())
        .build();

    let mut files = Vec::new();
    for entry in walker {
        let entry = entry?;
        if entry.file_type().map(|ft| ft.is_file()).unwrap_or(false) {
            files.push(entry.path().to_path_buf());
        }
    }

    // Apply user filter if provided
    if let Some(filter) = args.pattern {
        let normalized = normalize_glob_pattern(&filter);
        let filter_pattern = glob::Pattern::new(&normalized)?;

        files.retain(|f| {
            filter_pattern.matches(f.to_str().unwrap())
        });
    }

    // ... rest of test command
}
```

**Recommended: Use `ignore` crate** - it's battle-tested and handles edge cases properly.

5. **Negative Filter Logic (Updated for Glob Patterns):**

```rust
// In handle_symbols(), handle_source(), etc.:
if let Some(pattern) = args.pattern {
    if let Some(negative_pattern) = pattern.strip_prefix('!') {
        // Negative filter: exclude matching (glob pattern)
        let normalized = normalize_glob_pattern(negative_pattern);
        let glob_pattern = glob::Pattern::new(&normalized)?;

        symbols.retain(|s| !glob_pattern.matches(&s.name));
    } else {
        // Positive filter: include matching (glob pattern)
        let normalized = normalize_glob_pattern(&pattern);
        let glob_pattern = glob::Pattern::new(&normalized)?;

        symbols.retain(|s| glob_pattern.matches(&s.name));
    }
}
```

**Acceptance Criteria:**

**Format Flags:**
- [ ] `ta symbols --json` outputs JSON format
- [ ] `ta symbols --html` outputs HTML format
- [ ] `ta symbols` (no flags) outputs console format
- [ ] `ta symbols --json --html` returns error (mutually exclusive)

**Positional Patterns & Glob Normalization:**
- [ ] File `cli/src/utils.rs` created with `normalize_glob_pattern()` function
- [ ] `ta symbols Watch` filters to symbols matching `*Watch*` (auto-wildcard)
- [ ] `ta symbols src/**/*.ts` uses pattern as-is (already has glob syntax)
- [ ] `ta symbols '!Watch'` filters to symbols NOT matching `*Watch*`
- [ ] `ta symbols -n Watch` removed (no longer valid)
- [ ] All commands (source, test, file, deps) support positional pattern with glob normalization

**Test Command Improvements:**
- [ ] `ta test` uses improved base glob patterns:
  - [ ] Excludes `node_modules/**/*`
  - [ ] Includes `dist/**/*`
  - [ ] Includes `src/**/*.{test,spec}.{ts,tsx}`
  - [ ] Includes `{test,tests}/**/*.{ts,tsx}`
- [ ] `ta test` respects `.gitignore` exclusion patterns
- [ ] `ta test foobar` finds only test files with `*foobar*` in path
- [ ] `ignore` crate added to `cli/Cargo.toml` (recommended)
- [ ] .gitignore parsing works correctly (excludes node_modules, build dirs, etc.)
- [ ] Unit tests for `normalize_glob_pattern()` (5+ test cases)

**General:**
- [ ] `cargo test --bin ta` passes
- [ ] Integration tests verify glob normalization behavior
- [ ] Integration tests verify test command finds correct files

---

### Phase 2: Global Option Propagation Fixes

**Principal Owner:** Rust Developer

**Goal:** Add `global = true` attribute to flags so they work at both global and command level

**Dependencies:** Phase 1 (format flag changes)

**Blast Radius:** `cargo test --bin ta` (CLI tests only)

**Files to modify:**
- `cli/src/main.rs` - Add `global = true` to json, html, and verbose arguments

**Technical Details:**

The issue is user expectation: `ta symbols --json` feels more natural than `ta --json symbols`.

Current flags ARE global but don't work at subcommand level. Fix: Add `global = true` attribute.

```rust
// cli/src/main.rs - SIMPLE FIX
pub struct Cli {
    /// Output as JSON instead of console format
    #[arg(long, global = true, conflicts_with = "html")]  // Add global = true
    pub json: bool,

    /// Output as HTML instead of console format
    #[arg(long, global = true, conflicts_with = "json")]  // Add global = true
    pub html: bool,

    /// Enable verbose logging
    #[arg(short, long, global = true)]  // Add global = true
    pub verbose: bool,

    #[command(subcommand)]
    pub command: Commands,
}
```

This is a **3-line change** (one attribute addition per flag).

With `global = true`, these flags work in BOTH positions:
- `ta --json symbols` ✓
- `ta symbols --json` ✓

**Acceptance Criteria:**
- [ ] File `cli/src/main.rs` modified (3 lines changed)
- [ ] `ta --verbose symbols` works
- [ ] `ta symbols --verbose` works
- [ ] `ta --json symbols` works
- [ ] `ta symbols --json` works
- [ ] Help text indicates flags can be used globally or per-command
- [ ] `cargo test --bin ta` passes

---

### Phase 3: Security and Filter Improvements

**Principal Owner:** Rust Developer

**Goal:** Implement `--include-tests` logic, add glob pattern validation, improve error messages

**Dependencies:** None (independent of other phases)

**Blast Radius:** `cargo test --lib analyzer` + `cargo test --bin ta`

**Files to modify:**
- `cli/src/commands/source.rs` - Add test file filtering, glob validation
- `cli/src/commands/symbols.rs` - Add glob validation
- `cli/src/commands/test.rs` - Add glob validation
- `cli/src/commands/file.rs` - Add glob validation
- `cli/src/commands/deps.rs` - Add glob validation
- `tests/integration/cli_test.rs` - Add security tests

**Technical Details:**

1. **Glob Pattern Validation (all commands):**
```rust
// Before glob::glob() call:
if args.pattern.contains("..") {
    return Err(eyre!("Glob patterns cannot contain '..' for security reasons"))
        .with_help("Use absolute paths or patterns relative to current directory");
}

// After glob resolution, validate canonical paths don't escape CWD:
let cwd = std::env::current_dir()?;
for file in &files {
    if let Ok(canonical) = file.canonicalize() {
        if !canonical.starts_with(&cwd) {
            return Err(eyre!("Path traversal detected: {}", file.display()))
                .with_help("Patterns must resolve to paths within current directory");
        }
    }
}
```

2. **Test File Filtering (source.rs:19, 38):**
```rust
// After glob resolution, before analyzer call:
if !args.include_tests {
    files.retain(|p| {
        let path_str = p.to_string_lossy();
        // Use .ends_with() to avoid false positives like "contest.ts"
        !path_str.ends_with(".test.ts") &&
        !path_str.ends_with(".spec.ts") &&
        !path_str.ends_with(".test.tsx") &&
        !path_str.ends_with(".spec.tsx")
    });
}

// Also check if files is empty AFTER filtering:
if files.is_empty() {
    return Err(eyre!("No files found matching pattern: {}", args.pattern))
        .with_help("Try a broader pattern like '**/*.ts' or use --include-tests");
}
```

3. **Better Error Context:**
```rust
// Replace all glob::glob().wrap_err() with:
for entry in glob::glob(&args.pattern)
    .wrap_err_with(|| format!("Failed to read glob pattern: {}", args.pattern))?
{
    let path = entry.wrap_err("Invalid glob entry")?;
    // ...
}
```

**Acceptance Criteria:**
- [ ] `ta source` excludes `.test.ts` and `.spec.ts` files by default
- [ ] `ta source --include-tests` includes test files
- [ ] File `contest.ts` is NOT filtered (false positive check)
- [ ] `ta source '../../../etc/passwd'` returns error
- [ ] `ta source 'src/../../../etc/passwd'` returns error (canonicalization check)
- [ ] `ta source 'src/**/*.ts'` works (valid relative pattern)
- [ ] Error messages include helpful suggestions with `.with_help()`
- [ ] All commands validate glob patterns before execution
- [ ] Canonicalization check validates resolved paths stay within CWD
- [ ] Integration test `test_security_glob_validation` passes
- [ ] Integration test `test_security_canonicalization` passes
- [ ] `cargo test` passes

---

### Phase 4: Fix TypeError Metadata

**Principal Owner:** Rust Developer

**Goal:** Fix TypeError.file and TypeError.id fields to contain actual data

**Dependencies:** None

**Blast Radius:** `cargo test --lib visitors` + `cargo test --test cli`

**Files to modify:**
- `lib/src/visitors/type_error_visitor.rs` - Fix file/id fields
- `lib/src/analyzer.rs` - Pass file_path to visitor
- `tests/integration/cli_test.rs` - Update test assertions

**Technical Details:**

**Problem 1: TypeError.file always "unknown" (line 64)**

```rust
// CURRENT (type_error_visitor.rs:6-12)
pub struct TypeErrorVisitor<'a> {
    allocator: &'a Allocator,
    current_scope: Vec<String>,
    processed_errors: HashSet<String>,
    pub errors: Vec<TypeError>,
}

// NEEDED: Add file_path field
pub struct TypeErrorVisitor<'a> {
    allocator: &'a Allocator,
    file_path: String,  // NEW
    current_scope: Vec<String>,
    processed_errors: HashSet<String>,
    pub errors: Vec<TypeError>,
}

// Update new() method (line 15-21)
impl<'a> TypeErrorVisitor<'a> {
    pub fn new(allocator: &'a Allocator, file_path: String) -> Self {  // Add param
        Self {
            allocator,
            file_path,  // Store it
            current_scope: Vec::new(),
            processed_errors: HashSet::new(),
            errors: Vec::new(),
        }
    }
}

// Use it when creating errors (line 64)
file: self.file_path.clone(),  // Instead of "unknown".to_string()
```

**Update analyzer.rs to pass file path:**
```rust
// lib/src/analyzer.rs - In analyze_file_impl() around line 90
let mut visitor = TypeErrorVisitor::new(&allocator, path.to_string_lossy().to_string());
```

**Problem 2: TypeError.id always "error" (line 62)**

**IMPORTANT: First investigate OXC API for structured error code access before implementing string parsing.**

Check OXC 0.30 documentation for:
- `OxcDiagnostic::code()` method
- `OxcDiagnostic::error_code()` or similar
- Structured access to diagnostic metadata

If no structured API exists, fall back to string parsing:

```rust
// In visit_program() after semantic.check() (line 58)
for diagnostic in semantic.semantic().errors() {
    // Try to extract error code from diagnostic
    let error_id = extract_error_code(diagnostic);

    let error_key = format!("{:?}", diagnostic);
    if self.processed_errors.insert(error_key) {
        self.errors.push(TypeError {
            id: error_id,  // Use extracted code instead of "error"
            // ... rest unchanged
        });
    }
}

// Add helper method to TypeErrorVisitor
fn extract_error_code(diagnostic: &OxcDiagnostic) -> String {
    // OxcDiagnostic message format is often "TS1234: message text"
    let message = format!("{:?}", diagnostic);

    // Try to extract TS#### pattern
    if let Some(captures) = regex::Regex::new(r"TS(\d+)")
        .unwrap()
        .captures(&message)
    {
        return format!("TS{}", &captures[1]);
    }

    // Fallback to generic "error"
    "error".to_string()
}
```

**Alternative (no regex):**
```rust
fn extract_error_code(diagnostic: &OxcDiagnostic) -> String {
    let message = format!("{:?}", diagnostic);

    // Find "TS" followed by digits
    if let Some(ts_pos) = message.find("TS") {
        let rest = &message[ts_pos..];
        let digits: String = rest.chars()
            .skip(2)  // Skip "TS"
            .take_while(|c| c.is_ascii_digit())
            .collect();

        if !digits.is_empty() {
            return format!("TS{}", digits);
        }
    }

    "error".to_string()
}
```

**Acceptance Criteria:**
- [ ] **Investigation complete:** Document OXC API findings in code comments
- [ ] File `lib/src/visitors/type_error_visitor.rs` modified with file_path field
- [ ] File `lib/src/analyzer.rs` passes file path to TypeErrorVisitor::new()
- [ ] TypeError.file contains actual file path (e.g., "src/index.ts")
- [ ] TypeError.id contains actual error code when available (e.g., "TS2322")
- [ ] TypeError.id falls back to "error" when code cannot be extracted
- [ ] Error code extraction uses structured OXC API if available, string parsing if not
- [ ] Integration test verifies error.file is not "unknown"
- [ ] Integration test verifies error.id follows TS#### pattern or "error"
- [ ] Unit tests for error code extraction (3+ tests)
- [ ] `cargo test --lib visitors` passes (includes new unit tests)
- [ ] `cargo test --test cli` passes

---

### Phase 5: Colorization Implementation

**Principal Owner:** Rust Developer

**Goal:** Add ANSI color output to console format per design document specification

**Dependencies:** None (output layer only)

**Blast Radius:** `cargo test --lib output` (OutputFormatter tests)

**Files to modify:**
- `lib/Cargo.toml` - Add `colored = "2.1"` dependency
- `cli/Cargo.toml` - Add `atty = "0.2"` dependency
- `cli/src/main.rs` - Add NO_COLOR and TTY detection
- `lib/src/output.rs` - Implement colorization for all output types
- `tests/unit/output_test.rs` - Add colorization tests

**Technical Details:**

Reference: `/docs/ast-and-colorization.md` (design document)

**Color Scheme (Console):**

| Element | Color | Usage |
|---------|-------|-------|
| Error messages | RED | TypeError.message, error IDs |
| File paths | BLUE | TypeError.file, Symbol.file |
| Scope/context | CYAN | TypeError.scope |
| Keywords | MAGENTA | "function", "class", "interface", "type" |
| Symbol names | GREEN | Symbol.name |
| Types | YELLOW | Parameter types, return types |

**Implementation:**

```rust
// lib/Cargo.toml
[dependencies]
colored = "2.1"

// cli/Cargo.toml
[dependencies]
atty = "0.2"

// cli/src/main.rs - Add after color_eyre::install()
fn setup_colors() {
    // Respect NO_COLOR environment variable and TTY detection
    if std::env::var("NO_COLOR").is_ok() || !atty::is(atty::Stream::Stdout) {
        colored::control::set_override(false);
    }
}

// Call in main():
fn main() -> Result<()> {
    color_eyre::install()?;
    setup_colors();  // Add this
    // ... rest of main
}

// lib/src/output.rs
use colored::*;

impl OutputFormatter {
    pub fn format_type_errors(errors: &[TypeError], format: OutputFormat) -> String {
        match format {
            OutputFormat::Console => Self::format_type_errors_console(errors),
            OutputFormat::Json => Self::format_type_errors_json(errors),
            OutputFormat::Html => Self::format_type_errors_html(errors),
        }
    }

    fn format_type_errors_console(errors: &[TypeError]) -> String {
        let mut output = String::new();

        for error in errors {
            // Error header: [TS2322] in myFunction
            output.push_str(&format!(
                "{} {} {}\n",
                format!("[{}]", error.id).red().bold(),
                "in".white(),
                error.scope.cyan()
            ));

            // File and location: src/index.ts:42:10
            output.push_str(&format!(
                "  {} {}:{}:{}\n",
                "at".white(),
                error.file.blue(),
                error.line,
                error.column
            ));

            // Error message
            output.push_str(&format!(
                "  {}\n\n",
                error.message.red()
            ));
        }

        output
    }

    fn format_symbols_console(symbols: &[Symbol]) -> String {
        let mut output = String::new();

        for symbol in symbols {
            // Symbol kind in magenta
            let kind_str = format!("{:?}", symbol.kind).to_lowercase().magenta();

            // Symbol name in green
            let name_str = symbol.name.green().bold();

            // File path in blue
            let file_str = format!("{}:{}:{}", symbol.file, symbol.line, symbol.column).blue();

            output.push_str(&format!("{} {} {}\n", kind_str, name_str, file_str));

            // Parameters/properties in yellow
            if !symbol.parameters.is_empty() {
                let params = symbol.parameters.join(", ").yellow();
                output.push_str(&format!("  ({})\n", params));
            }

            if !symbol.properties.is_empty() {
                output.push_str(&format!("  {}\n", "properties:".white()));
                for prop in &symbol.properties {
                    output.push_str(&format!("    {}\n", prop.yellow()));
                }
            }

            output.push('\n');
        }

        output
    }

    // Similar for format_tests_console, format_dependencies_console, etc.
}
```

**HTML Colorization:**

HTML should use semantic classes that mirror console colors:

```rust
fn format_type_errors_html(errors: &[TypeError]) -> String {
    let mut output = String::from("<div class='type-errors'>\n");

    for error in errors {
        output.push_str(&format!(
            r#"<div class="error-block">
  <div class="error-header">
    <span class="error-id">[{}]</span>
    <span class="keyword">in</span>
    <span class="scope">{}</span>
  </div>
  <div class="error-location">
    <span class="keyword">at</span>
    <span class="file-path">{}:{}:{}</span>
  </div>
  <div class="error-message">{}</div>
</div>
"#,
            error.id, error.scope, error.file, error.line, error.column, error.message
        ));
    }

    output.push_str("</div>");
    output
}
```

**CSS Classes (for documentation):**
```css
.error-id { color: #ff4444; font-weight: bold; }
.file-path { color: #4444ff; }
.scope { color: #44ffff; }
.keyword { color: #ff44ff; }
.symbol-name { color: #44ff44; font-weight: bold; }
.type-annotation { color: #ffff44; }
```

**Acceptance Criteria:**
- [ ] File `lib/Cargo.toml` includes `colored = "2.1"` dependency
- [ ] File `cli/Cargo.toml` includes `atty = "0.2"` dependency
- [ ] File `cli/src/main.rs` includes `setup_colors()` function
- [ ] NO_COLOR environment variable disables colors
- [ ] Non-TTY output disables colors automatically
- [ ] File `lib/src/output.rs` implements colorized console output (>300 lines added)
- [ ] TypeError output uses RED for errors, BLUE for files, CYAN for scopes
- [ ] Symbol output uses GREEN for names, MAGENTA for kinds, YELLOW for types
- [ ] HTML output uses semantic CSS classes consistent with console colors
- [ ] Unit tests verify ANSI codes present in console output
- [ ] Unit tests verify specific color codes (RED=31, BLUE=34, CYAN=36, etc.)
- [ ] Unit tests verify HTML contains correct class attributes
- [ ] Integration test: NO_COLOR env var disables colors
- [ ] Integration test: piped output has no ANSI codes
- [ ] `cargo test --lib output` passes with 10+ new tests
- [ ] Visual verification: `ta source` shows colored output in terminal

---

### Phase 6: Testing and Validation

**Principal Owner:** Feature Tester (Rust)

**Goal:** Ensure all changes are thoroughly tested and no regressions introduced

**Dependencies:** Phases 1-5 complete

**Blast Radius:** `cargo test` (full test suite)

**Files to create/modify:**
- `tests/integration/cli_test.rs` - Add tests for new features
- `tests/integration/helpers.rs` - Add shared test utilities
- `tests/unit/output_test.rs` - Add colorization tests
- `lib/src/visitors/type_error_visitor.rs` - Add unit tests for error code extraction
- `tests/fixtures/` - Ensure all required fixture files exist

**Technical Details:**

**Test Helper Module:**

```rust
// tests/integration/helpers.rs

pub fn assert_valid_json(output: &str) {
    serde_json::from_str::<serde_json::Value>(output)
        .expect("Output should be valid JSON");
}

pub fn assert_ansi_color(output: &str, color_code: &str) {
    assert!(output.contains(&format!("\x1b[{}m", color_code)),
        "Expected ANSI color code {}", color_code);
}

pub fn count_symbols_in_output(output: &str, symbol_type: &str) -> usize {
    output.lines().filter(|l| l.contains(symbol_type)).count()
}

pub fn assert_no_ansi_codes(output: &str) {
    assert!(!output.contains("\x1b["), "Output should not contain ANSI codes");
}
```

**Required Test Fixtures:**

Before Phase 6 implementation, ensure these fixtures exist:

```
tests/fixtures/
├── sample.ts           - Clean file with MyClass, OtherClass (no Test* symbols)
├── errors.ts           - File with TS2322 type mismatch error
├── sample.test.ts      - Test file with TestClass symbol
├── sample.spec.ts      - Spec file for --include-tests verification
├── multi-error.ts      - File with 3+ different error types
└── contest.ts          - File to test false positive filtering
```

**New Integration Tests:**

```rust
// tests/integration/cli_test.rs
mod helpers;  // Import helper module

// Phase 0: Directory switching tests
#[test]
fn test_dir_flag_changes_working_directory() {
    // Create a fixture in a subdirectory
    let temp_dir = std::env::temp_dir().join("ta_test_dir");
    std::fs::create_dir_all(&temp_dir).unwrap();

    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["--dir", temp_dir.to_str().unwrap(), "source", "**/*.ts"])
        .output()
        .unwrap();

    // Should execute from temp_dir, not current dir
    assert!(output.status.success() ||
            String::from_utf8(output.stderr).unwrap().contains("No files found"));
}

#[test]
fn test_dir_flag_short_form() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["-d", "fixtures", "symbols", "sample.ts"])
        .output()
        .unwrap();

    assert!(output.status.success());
}

#[test]
fn test_dir_flag_nonexistent_error() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["--dir", "nonexistent_directory_12345", "source"])
        .output()
        .unwrap();

    assert!(!output.status.success());
    let stderr = String::from_utf8(output.stderr).unwrap();
    assert!(stderr.contains("Failed to change to directory") ||
            stderr.contains("No such file or directory"));
}

#[test]
fn test_dir_flag_with_relative_patterns() {
    // When using --dir, relative patterns should be relative to that dir
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["--dir", "fixtures", "source", "*.ts"])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stderr = String::from_utf8(output.stderr).unwrap();
    // Should find files in fixtures/ directory
    assert!(stderr.contains("Analyzing") || stderr.contains("files"));
}

// Phase 1: Format flag tests
#[test]
fn test_json_flag() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "--json", "fixtures/sample.ts"])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();

    // Should be valid JSON
    let _: serde_json::Value = serde_json::from_str(&stdout).unwrap();
}

#[test]
fn test_html_flag() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "--html", "fixtures/sample.ts"])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();

    // Should contain HTML tags
    assert!(stdout.contains("<div"));
    assert!(stdout.contains("class="));
}

#[test]
fn test_json_html_mutually_exclusive() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "--json", "--html", "fixtures/sample.ts"])
        .output()
        .unwrap();

    assert!(!output.status.success());
    let stderr = String::from_utf8(output.stderr).unwrap();
    assert!(stderr.contains("cannot be used with"));
}

#[test]
fn test_positional_filter() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "fixtures/sample.ts", "MyClass"])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();

    // Should only contain symbols with "MyClass" in name
    assert!(stdout.contains("MyClass"));
    assert!(!stdout.contains("OtherClass"));
}

#[test]
fn test_negative_filter() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "fixtures/sample.ts", "!Test"])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();

    // Should NOT contain symbols with "Test" in name
    assert!(!stdout.contains("TestClass"));
    assert!(stdout.contains("MyClass"));
}

#[test]
fn test_include_tests_flag() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["source", "fixtures/**/*.ts"])
        .output()
        .unwrap();

    let stderr = String::from_utf8(output.stderr).unwrap();
    let file_count_without: usize = stderr
        .split_whitespace()
        .nth(1)
        .unwrap()
        .parse()
        .unwrap();

    let output_with = Command::cargo_bin("ta")
        .unwrap()
        .args(&["source", "--include-tests", "fixtures/**/*.ts"])
        .output()
        .unwrap();

    let stderr_with = String::from_utf8(output_with.stderr).unwrap();
    let file_count_with: usize = stderr_with
        .split_whitespace()
        .nth(1)
        .unwrap()
        .parse()
        .unwrap();

    // Should analyze more files with --include-tests
    assert!(file_count_with > file_count_without);
}

#[test]
fn test_glob_path_traversal_blocked() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["source", "../../../etc/passwd"])
        .output()
        .unwrap();

    assert!(!output.status.success());
    let stderr = String::from_utf8(output.stderr).unwrap();
    assert!(stderr.contains("cannot contain '..'"));
}

#[test]
fn test_verbose_flag_command_level() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "--verbose", "fixtures/sample.ts"])
        .env("RUST_LOG", "debug")
        .output()
        .unwrap();

    let stderr = String::from_utf8(output.stderr).unwrap();
    // Should contain debug logging
    assert!(stderr.contains("debug") || stderr.contains("DEBUG"));
}

#[test]
fn test_type_error_file_field() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["source", "--json", "fixtures/errors.ts"])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    let errors: Vec<serde_json::Value> = serde_json::from_str(&stdout).unwrap();

    if let Some(first_error) = errors.first() {
        let file = first_error["file"].as_str().unwrap();
        assert_ne!(file, "unknown");
        assert!(file.ends_with("errors.ts"));
    }
}

#[test]
fn test_type_error_id_field() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["source", "--json", "fixtures/errors.ts"])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    let errors: Vec<serde_json::Value> = serde_json::from_str(&stdout).unwrap();

    if let Some(first_error) = errors.first() {
        let id = first_error["id"].as_str().unwrap();
        // Should be either TS#### or "error"
        assert!(id.starts_with("TS") || id == "error");
    }
}

#[test]
fn test_empty_glob_pattern() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["source", "nonexistent/**/*.ts"])
        .output()
        .unwrap();

    let stderr = String::from_utf8(output.stderr).unwrap();
    assert!(stderr.contains("No files found"));
}

#[test]
fn test_false_positive_filtering() {
    // Ensure "contest.ts" is NOT filtered by test file filter
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["source", "fixtures/contest.ts"])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stderr = String::from_utf8(output.stderr).unwrap();
    assert!(stderr.contains("Analyzing 1 files"));  // Should analyze it
}

#[test]
fn test_canonicalization_security() {
    // Test that normalized paths with .. are caught
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["source", "src/../../../etc/passwd"])
        .output()
        .unwrap();

    assert!(!output.status.success());
    let stderr = String::from_utf8(output.stderr).unwrap();
    assert!(stderr.contains("Path traversal") || stderr.contains(".."));
}

#[test]
fn test_no_color_env_var() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "fixtures/sample.ts"])
        .env("NO_COLOR", "1")
        .output()
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    helpers::assert_no_ansi_codes(&stdout);
}

#[test]
fn test_piped_output_no_colors() {
    // When output is piped (not a TTY), colors should be disabled
    // This is implicitly tested by running in test harness
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "fixtures/sample.ts"])
        .output()
        .unwrap();

    let stdout = String::from_utf8(output.stdout).unwrap();
    // In test environment, stdout is not a TTY
    helpers::assert_no_ansi_codes(&stdout);
}

#[test]
fn test_specific_ansi_colors() {
    use std::process::Stdio;

    // Force TTY-like behavior for this test
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["source", "fixtures/errors.ts"])
        .env("CLICOLOR_FORCE", "1")  // Force colors
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()
        .unwrap();

    let stdout = String::from_utf8(output.stdout).unwrap();
    // Verify specific color codes if colors are forced
    if stdout.contains("\x1b[") {
        helpers::assert_ansi_color(&stdout, "31");  // RED for errors
        helpers::assert_ansi_color(&stdout, "34");  // BLUE for file paths
    }
}

// Glob normalization tests
#[test]
fn test_glob_normalization_auto_wildcard() {
    // Simple pattern should get wildcards added
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "fixtures/sample.ts", "MyClass"])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();

    // Should match symbols containing "MyClass" (with auto wildcards: *MyClass*)
    assert!(stdout.contains("MyClass"));
}

#[test]
fn test_glob_normalization_preserves_pattern() {
    // Pattern with glob syntax should be preserved
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "fixtures/*.ts", "*Class"])
        .output()
        .unwrap();

    assert!(output.status.success());
    // Pattern *Class should remain as-is (already has glob syntax)
}

#[test]
fn test_glob_filter_with_subdirectory() {
    // User wants to filter to files in "foobar" subdirectory
    // This tests the common use case: ta test foobar
    // Should match files with path containing *foobar*

    // Create test fixtures in subdirectories
    std::fs::create_dir_all("fixtures/foobar").ok();
    std::fs::write("fixtures/foobar/test.ts", "export const x = 1;").ok();

    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["symbols", "fixtures/**/*.ts", "foobar"])
        .output()
        .unwrap();

    let stdout = String::from_utf8(output.stdout).unwrap();
    // Should only include files with "foobar" in path
    assert!(stdout.contains("foobar") || output.status.success());
}

// Test command improvements
#[test]
fn test_command_improved_base_patterns() {
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["test", "fixtures/**/*"])
        .output()
        .unwrap();

    let stderr = String::from_utf8(output.stderr).unwrap();

    // Should find test files in src/ and test/ directories
    // Should exclude node_modules automatically
    assert!(!stderr.contains("node_modules"));
}

#[test]
fn test_command_respects_gitignore() {
    // Create a temporary .gitignore file
    let gitignore_content = "build/\ndist/\n*.log";
    std::fs::write(".gitignore", gitignore_content).ok();

    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["test"])
        .output()
        .unwrap();

    let stderr = String::from_utf8(output.stderr).unwrap();

    // Should not analyze files in gitignore patterns
    assert!(!stderr.contains("build/"));
    assert!(!stderr.contains("dist/"));

    // Cleanup
    std::fs::remove_file(".gitignore").ok();
}

#[test]
fn test_command_with_subdirectory_filter() {
    // ta test foobar should find only test files with "foobar" in path
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["test", "foobar"])
        .output()
        .unwrap();

    let stderr = String::from_utf8(output.stderr).unwrap();
    // Should apply *foobar* filter to test files
    assert!(output.status.success() || stderr.contains("No files found"));
}

#[test]
fn test_command_finds_multiple_test_patterns() {
    // Should find both .test.ts and .spec.ts files
    // Should find files in src/, test/, and tests/ directories
    let output = Command::cargo_bin("ta")
        .unwrap()
        .args(&["test", "fixtures/**/*"])
        .output()
        .unwrap();

    let stderr = String::from_utf8(output.stderr).unwrap();

    // If test files exist, should analyze them
    if stderr.contains("Analyzing") {
        // Verify it found test/spec files
        assert!(stderr.contains("files"));
    }
}
```

**Unit Tests for Colorization:**

```rust
// tests/unit/output_test.rs

#[test]
fn test_console_output_contains_ansi_colors() {
    use colored::*;

    let errors = vec![TypeError {
        id: "TS2322".to_string(),
        message: "Type mismatch".to_string(),
        file: "test.ts".to_string(),
        line: 42,
        column: 10,
        scope: "myFunction".to_string(),
    }];

    let output = OutputFormatter::format_type_errors(&errors, OutputFormat::Console);

    // Should contain ANSI escape codes
    assert!(output.contains("\x1b["));  // ANSI escape sequence
    assert!(output.contains("TS2322"));
    assert!(output.contains("test.ts"));
}

#[test]
fn test_html_output_contains_css_classes() {
    let errors = vec![TypeError {
        id: "TS2322".to_string(),
        message: "Type mismatch".to_string(),
        file: "test.ts".to_string(),
        line: 42,
        column: 10,
        scope: "myFunction".to_string(),
    }];

    let output = OutputFormatter::format_type_errors(&errors, OutputFormat::Html);

    assert!(output.contains("class=\"error-id\""));
    assert!(output.contains("class=\"file-path\""));
    assert!(output.contains("class=\"scope\""));
    assert!(output.contains("class=\"error-message\""));
}
```

**Unit Tests for Error Code Extraction:**

```rust
// lib/src/visitors/type_error_visitor.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_error_code_with_ts_prefix() {
        // Mock diagnostic message containing TS2322
        let message = "TS2322: Type 'string' is not assignable to type 'number'";
        // Would need to create mock OxcDiagnostic or test helper
        // For now, test the logic directly

        assert!(message.contains("TS2322"));
    }

    #[test]
    fn test_extract_error_code_fallback() {
        let message = "Some generic error without code";
        // Should fall back to "error"
    }
}
```

**Unit Tests for Glob Normalization:**

```rust
// cli/src/utils.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_glob_pattern_no_wildcards() {
        // Pattern with no glob syntax should get wildcards added
        assert_eq!(normalize_glob_pattern("foobar"), "*foobar*");
        assert_eq!(normalize_glob_pattern("MyClass"), "*MyClass*");
        assert_eq!(normalize_glob_pattern("test"), "*test*");
    }

    #[test]
    fn test_normalize_glob_pattern_with_start_wildcard() {
        // Pattern starting with wildcard should only add end wildcard
        assert_eq!(normalize_glob_pattern("*Class"), "*Class*");
        assert_eq!(normalize_glob_pattern("?oo"), "?oo*");
    }

    #[test]
    fn test_normalize_glob_pattern_with_end_wildcard() {
        // Pattern ending with wildcard should only add start wildcard
        assert_eq!(normalize_glob_pattern("Class*"), "*Class*");
        assert_eq!(normalize_glob_pattern("foo?"), "*foo?");
    }

    #[test]
    fn test_normalize_glob_pattern_both_wildcards() {
        // Pattern with wildcards on both ends should remain unchanged
        assert_eq!(normalize_glob_pattern("*foobar*"), "*foobar*");
        assert_eq!(normalize_glob_pattern("**/test/*"), "**/test/*");
        assert_eq!(normalize_glob_pattern("src/**/*.ts"), "src/**/*.ts");
    }

    #[test]
    fn test_normalize_glob_pattern_with_braces() {
        // Pattern with braces should be preserved
        assert_eq!(normalize_glob_pattern("{test,spec}"), "{test,spec}");
        assert_eq!(normalize_glob_pattern("*.{ts,tsx}"), "*.{ts,tsx}*");
    }

    #[test]
    fn test_normalize_glob_pattern_with_brackets() {
        // Pattern with brackets should be preserved
        assert_eq!(normalize_glob_pattern("[abc]"), "[abc]");
        assert_eq!(normalize_glob_pattern("test[123]"), "*test[123]*");
    }

    #[test]
    fn test_normalize_glob_pattern_complex() {
        // Complex glob patterns should work correctly
        assert_eq!(normalize_glob_pattern("src/**/*.test.{ts,tsx}"), "src/**/*.test.{ts,tsx}");
        assert_eq!(normalize_glob_pattern("**/foobar/**"), "**/foobar/**");
    }
}
```

**Test Fixtures:**

Ensure test fixtures exist:
- `tests/fixtures/sample.ts` - Clean TypeScript file with various symbols (MyClass, OtherClass)
- `tests/fixtures/errors.ts` - File with intentional type errors
- `tests/fixtures/sample.test.ts` - Test file to verify --include-tests
- `tests/fixtures/foobar/` - Subdirectory for testing path filters
- `tests/fixtures/contest.ts` - File to verify false positive filtering

**Acceptance Criteria:**
- [ ] Test helper module created at `tests/integration/helpers.rs`
- [ ] All required test fixtures exist and are valid
- [ ] 35+ new integration tests added covering:
  - **Phase 0**: Directory switching (4 tests)
  - **Phase 1**: Format flags (JSON, HTML, mutual exclusivity) (3 tests)
  - **Phase 1**: Positional filters (positive and negative) (2 tests)
  - **Phase 1**: Glob normalization (3 tests - auto-wildcard, preserves pattern, subdirectory filter)
  - **Phase 1**: Test command improvements (4 tests - base patterns, gitignore, subdirectory filter, multiple patterns)
  - **Phase 3**: Security (path traversal, canonicalization) (3 tests)
  - **Phase 3**: Edge cases (empty results, false positives) (2 tests)
  - **Phase 2**: Global flag propagation (1 test)
  - **Phase 4**: TypeError metadata (file, id fields) (2 tests)
  - **Phase 5**: Colorization (NO_COLOR, TTY detection, specific ANSI codes) (3 tests)
  - **Other**: Include-tests, verbose flag, etc. (6 tests)
- [ ] 5+ new unit tests for colorization
- [ ] 3+ new unit tests for error code extraction
- [ ] 7 new unit tests for glob normalization (cli/src/utils.rs)
- [ ] All existing 26 tests still pass
- [ ] `cargo test` shows 67+ total tests passing (26 existing + 41 new)
- [ ] No new clippy warnings
- [ ] Test coverage >75% on changed files
- [ ] All edge cases covered (empty results, invalid patterns, false positives, glob normalization edge cases)
- [ ] Security validation tests pass (path traversal, canonicalization)
- [ ] Directory switching tests verify monorepo support
- [ ] Glob normalization tests verify auto-wildcard expansion works correctly

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit Tests:** `#[cfg(test)] mod tests` blocks in each module
  - OutputFormatter colorization logic
  - Error code extraction
  - Filter logic (positive/negative)

- **Integration Tests:** `tests/integration/cli_test.rs`
  - End-to-end CLI usage
  - Flag combinations
  - Output format verification
  - Security validation

- **Manual Testing Checklist:**
  - [ ] Visual verification of colors in terminal
  - [ ] HTML output in browser
  - [ ] Verbose logging shows debug output
  - [ ] Help text is clear and accurate

### Security Considerations

- **Path Traversal Prevention:** All glob patterns validated for `..` sequences
- **Input Validation:** Pattern arguments validated before processing
- **Error Messages:** Avoid leaking sensitive path information in errors

### Performance Considerations

- **Colorization Overhead:** `colored` crate has minimal overhead (compile-time)
- **No Regex in Hot Path:** Error code extraction happens once per error, not per file
- **Existing Rayon Parallelism:** Unchanged, continues to work

### Backward Compatibility

**Breaking Changes:**
1. ✅ `ta symbols -n Watch` → `ta symbols Watch` (removes `-n` flag)
2. ✅ `ta --format json symbols` → `ta --json symbols` OR `ta symbols --json`

**Migration Guide:**
- Users with scripts using `-n/--name` will need to update
- Users with `--format` will need to switch to `--json` or `--html`
- Consider deprecation warning in v1.1.0, remove in v2.0.0

**Mitigation:**
- Update README with migration notes
- Add deprecation notices to help text if keeping old flags temporarily

### Documentation Updates

Files to update after implementation:
- `README.md` - Update CLI examples with new flags
- `CHANGELOG.md` - Document breaking changes and new features
- `/docs/ast-and-colorization.md` - Mark colorization as implemented

## Parallelization Opportunities

Most phases are independent and can be worked in parallel:

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| Group A | Phase 0, Phase 1, Phase 3, Phase 4, Phase 5 | No dependencies - different code areas |
| Group B | Phase 2 | Depends on Phase 1 (format flag changes) |
| Group C | Phase 6 | Depends on all phases complete |

### Implementation Timeline

```text
─────────────────────────────────────────────────►

Group A: ████████████ (Phases 0, 1, 3, 4, 5 in parallel)
              │
Group B:      └──████ (Phase 2 - needs Phase 1)
                    │
Group C:            └──██████ (Phase 6 - testing)
```

**Detailed Phase Breakdown:**

- **Phase 0, 1, 3, 4, 5** can ALL run in parallel:
  - Phase 0: `cli/src/main.rs` (add --dir flag, change directory early in main())
  - Phase 1: `cli/src/main.rs` + `cli/src/commands/*.rs` (argument parsing)
  - Phase 3: `cli/src/commands/*.rs` (different functions than Phase 1)
  - Phase 4: `lib/src/visitors/type_error_visitor.rs` + `lib/src/analyzer.rs` (library layer)
  - Phase 5: `lib/src/output.rs` + `cli/src/main.rs` (output layer + color setup)

**Note:** While Phase 0, 1, and 5 all touch `cli/src/main.rs`, they modify different parts:
  - Phase 0: Adds `dir` field to Cli struct, adds directory change in main()
  - Phase 1: Modifies format flags in Cli struct
  - Phase 5: Adds color setup function call in main()

These changes don't conflict and can be done in parallel, then merged.

- **Phase 2** waits for Phase 1 to add the json/html flags before adding `global = true`

- **Phase 6** validates all changes together

### Synchronization Points

1. **After Group A + B:** All CLI argument changes finalized
2. **After Group C:** All library changes finalized
3. **Final (Group D):** Full integration testing

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Breaking changes anger users | Medium | Document migration clearly, consider deprecation period |
| Colorization breaks in some terminals | Low | Use `colored` crate which handles terminal detection |
| Error code extraction fails for some OXC versions | Medium | Fall back to "error" gracefully, add extensive tests |
| Test file filtering too aggressive | Low | Start conservative (.test./.spec.), document in help |
| Glob validation too restrictive | Low | Only block `..`, allow all other patterns |
| Clippy warnings from `colored` crate | Low | `colored` is well-maintained, unlikely |

## Open Questions

- [ ] Should we support custom color schemes via config file? (Defer to v1.1.0)
- [ ] Should negative filters support regex instead of just substring? (Defer)
- [ ] Should we add `--no-color` flag to disable colorization? (Yes, add in Phase 5)
- [ ] Should JSON output include console/HTML representations as README promises? (Future enhancement)
- [ ] Should we keep `-n/--name` as deprecated alias during transition? (TBD - discuss with users)

---

## Implementation Notes

### Clap Mutually Exclusive Flags

To make `--json` and `--html` mutually exclusive:

```rust
#[derive(Parser)]
pub struct Cli {
    /// Output as JSON
    #[arg(long, conflicts_with = "html", global = true)]
    pub json: bool,

    /// Output as HTML
    #[arg(long, conflicts_with = "json", global = true)]
    pub html: bool,

    // ...
}
```

### Colored Crate: Disable on Non-TTY

```rust
// In main.rs after color_eyre::install()
if !atty::is(atty::Stream::Stdout) {
    colored::control::set_override(false);
}
```

Add to `cli/Cargo.toml`:
```toml
atty = "0.2"
```

### Testing Colorized Output

Use `colored::control::SHOULD_COLORIZE` or test raw strings:

```rust
#[test]
fn test_colors() {
    colored::control::set_override(true);  // Force colors in tests

    let output = format_errors(...);
    assert!(output.contains("\x1b[31m"));  // RED ANSI code

    colored::control::unset_override();
}
```

---

## Next Steps After Plan Approval

1. **Create feature branch:** `git checkout -b fix/small-adjustments`
2. **Implement phases in parallel groups per timeline above**
3. **Run tests after each phase:** `cargo test`
4. **Manual verification:** Test all CLI commands with new flags
5. **Update documentation:** README, CHANGELOG
6. **Create PR with detailed changelog**

---

## Success Criteria

### Must Have (v1.1.0)
- [ ] All 12 functional requirements (FR-0 through FR-9, including FR-2a and FR-2b) implemented
  - [ ] FR-0: `--dir/-d` global switch for monorepo support (CRITICAL)
  - [ ] FR-1: Format flags (`--json`, `--html`)
  - [ ] FR-2: Positional pattern arguments
  - [ ] FR-2a: Glob pattern normalization with auto-wildcard expansion (CRITICAL)
  - [ ] FR-2b: Improved test command base patterns and .gitignore support (CRITICAL)
  - [ ] FR-3 through FR-9: All other requirements
- [ ] All 4 non-functional requirements (NFR-1 through NFR-4) met
- [ ] 67+ tests passing (26 existing + 41 new)
- [ ] File `cli/src/utils.rs` created with glob normalization utilities
- [ ] `ignore` crate added to `cli/Cargo.toml` for .gitignore parsing
- [ ] No clippy warnings
- [ ] README updated with new CLI examples:
  - [ ] `--dir` for monorepo support
  - [ ] Glob pattern filtering (e.g., `ta test foobar`)
  - [ ] Improved test command patterns
- [ ] CHANGELOG documents breaking changes and new features

### Nice to Have (Future)
- [ ] JSON output includes console/HTML representations
- [ ] Custom color schemes via config
- [ ] Regex support in filters
- [ ] Property-based tests for filter logic
- [ ] Snapshot tests for output formats
