# Fix "Must Fix Before 1.0" Issues - TA CLI (REVISED)

**Created:** 2025-12-22
**Status:** Reviewed - Ready for Implementation
**Review Document:** `.ai/code-reviews/20251220.ta-cli-implementation-plan-review.md`
**Reviewers:** Rust Developer, Feature Tester (Rust)

## Executive Summary

**MAJOR REVISION:** After parallel sub-agent review and codebase analysis, this plan has been significantly revised. Of the 5 original "Must Fix" issues from the code review, **only 1 actually needs fixing**: implementing external handler execution for watch mode.

**Resolution Summary:**
| Issue | Status | Reason |
|-------|--------|--------|
| TypeError.file field | ✅ Already fixed | Set in visitor, updated in `type_errors.rs:19-21` |
| TypeError.id field | ✅ Already fixed | Extracted via `extract_error_code()` in `type_error_visitor.rs:90-99` |
| `--include-tests` filtering | ✅ Already implemented | Test file filtering working in `source.rs:68-77` |
| Glob pattern validation | ✅ Not applicable | Uses substring filters, not globs; no security issue |
| **External handler execution** | ❌ **Needs implementation** | Only logs to console currently |

This plan focuses on implementing **one comprehensive phase**: External Handler Execution with validation, non-blocking execution, timeouts, and thorough testing.

---

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Watch mode accepts `--${Event}` and `--Handler` CLI flags | High | Rust Developer |
| FR-2 | Handlers validated before watch starts (exists, executable, Bun check) | High | Rust Developer |
| FR-3 | Handlers receive event data via `TA_EVENT` and `TA_EVENT_DATA` env vars | High | Rust Developer |
| FR-4 | TypeScript handlers automatically executed via Bun | High | Rust Developer |
| FR-5 | Handler execution is non-blocking with 30s timeout | High | Rust Developer |
| FR-6 | Handler failures logged but don't crash watcher | High | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Security: Handler validation before execution | 100% validated | Rust Developer |
| NFR-2 | Performance: Handlers don't block file watching | Non-blocking execution | Rust Developer |
| NFR-3 | Reliability: Handler timeouts prevent hangs | 30 second timeout | Rust Developer |
| NFR-4 | Test coverage for new code | 100% of new functions | Feature Tester (Rust) |
| NFR-5 | No breaking changes to existing commands | All current tests pass | Rust Developer |
| NFR-6 | Cross-platform: Works on Unix and Windows | Platform-specific handling | Rust Developer |

---

## Architecture Overview

### Component Diagram

```
┌─────────────────────────────────────────────────────┐
│ CLI Layer (ta)                                       │
│  ┌────────────────────────────────────────────────┐ │
│  │ watch.rs                                        │ │
│  │  ┌────────────┐    ┌─────────────────────────┐│ │
│  │  │ WatchArgs  │───▶│ CliWatchHandler         ││ │
│  │  │ - Handlers │    │ - ValidatedHandler map  ││ │
│  │  └────────────┘    │ - Dispatches to exe     ││ │
│  │                    └─────────────────────────┘│ │
│  └────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
                    │ implements
                    ▼
┌─────────────────────────────────────────────────────┐
│ Library Layer (ta-lib)                               │
│  ┌──────────────────────────────────────────────┐  │
│  │ watcher.rs                                    │  │
│  │  trait WatchHandler {                        │  │
│  │    fn handle_event(&mut self, event)         │  │
│  │  }                                            │  │
│  │  (No changes needed - architecture correct)  │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

### Data Flow

1. **Initialization:**
   - User runs `ta watch src/ --SymbolAdded ./handler.sh`
   - `WatchArgs` parses CLI arguments
   - `CliWatchHandler::new()` validates each handler
     - Check file exists
     - Check executable permissions (POSIX only)
     - Check Bun installed (TypeScript handlers)
   - `FileWatcher` starts with validated handler

2. **Event Detection:**
   - File change detected by `notify-debouncer-full`
   - `FileWatcher` analyzes file, detects event (e.g., SymbolAdded)
   - Calls `CliWatchHandler::handle_event()` with event data

3. **Handler Execution:**
   - `CliWatchHandler` serializes event to JSON
   - Dispatches to registered handler(s)
   - Handler executes in background thread with 30s timeout
   - Output/errors logged to stderr
   - Watcher continues without blocking

---

## Phase 1: Implement External Handler Execution

**Principal Owner:** Rust Developer
**Dependencies:** None
**Blast Radius:** `cargo test` (full suite - foundational watch infrastructure change)

### New Dependencies

Add to `/Volumes/coding/personal/ta/cli/Cargo.toml`:

```toml
[dependencies]
which = "6.0"  # Cross-platform binary location (Bun detection)
```

### Deliverables

- [ ] Modified `/Volumes/coding/personal/ta/cli/src/commands/watch.rs` (250+ new lines)
- [ ] `WatchArgs` extended with handler CLI flags
- [ ] `ValidatedHandler` struct with validation and execution logic
- [ ] `CliWatchHandler` dispatches to external handlers
- [ ] Unit tests in `watch.rs` `#[cfg(test)]` module
- [ ] Integration test with temp handler scripts

---

### Technical Implementation

#### Step 1: Extend `WatchArgs` for Handler CLI Flags

**File:** `/Volumes/coding/personal/ta/cli/src/commands/watch.rs`

**Location:** Lines 17-21 (replace existing `WatchArgs`)

```rust
use std::path::PathBuf;
use clap::Args;
use ta_lib::output::OutputFormat;

#[derive(Debug, Args)]
pub struct WatchArgs {
    /// Paths to watch
    #[arg(required = true)]
    pub paths: Vec<PathBuf>,

    /// Output format
    #[arg(short, long, value_enum, default_value = "console")]
    pub format: OutputFormat,

    // Event-specific handlers
    /// Handler for SymbolAdded events
    #[arg(long = "SymbolAdded")]
    pub on_symbol_added: Option<PathBuf>,

    /// Handler for SymbolRemoved events
    #[arg(long = "SymbolRemoved")]
    pub on_symbol_removed: Option<PathBuf>,

    /// Handler for TestStatusChanged events
    #[arg(long = "TestStatusChanged")]
    pub on_test_status_changed: Option<PathBuf>,

    /// Handler for NewFailingTest events
    #[arg(long = "NewFailingTest")]
    pub on_new_failing_test: Option<PathBuf>,

    /// Handler for TestFixed events
    #[arg(long = "TestFixed")]
    pub on_test_fixed: Option<PathBuf>,

    /// Handler for NewTestAdded events
    #[arg(long = "NewTestAdded")]
    pub on_new_test_added: Option<PathBuf>,

    /// Generic handler for all events
    #[arg(long = "Handler")]
    pub on_any_event: Option<PathBuf>,
}
```

**CLI Usage Examples:**
```bash
# Single event handler
ta watch src/ --SymbolAdded ./handlers/symbol-added.sh

# TypeScript handler (auto-detects .ts extension, uses Bun)
ta watch src/ --TestFixed ./handlers/test-fixed.ts

# Multiple handlers
ta watch src/ \
  --SymbolAdded ./handlers/symbol-added.sh \
  --TestFixed ./handlers/test-fixed.ts

# Generic handler for all events
ta watch src/ --Handler ./handlers/log-all.sh
```

---

#### Step 2: Create `ValidatedHandler` Struct

**File:** `/Volumes/coding/personal/ta/cli/src/commands/watch.rs`

**Location:** Add after `WatchArgs` (around line 57)

```rust
use std::time::Duration;
use std::path::Path;
use color_eyre::eyre::{Result, eyre, Context};

/// A validated external handler (shell script or TypeScript file)
#[derive(Debug, Clone)]
struct ValidatedHandler {
    path: PathBuf,
    is_typescript: bool,
}

impl ValidatedHandler {
    /// Validate a handler file exists and is executable
    fn new(path: PathBuf) -> Result<Self> {
        // Check file exists
        if !path.exists() {
            return Err(eyre!("Handler file does not exist: {}", path.display()))
                .with_help("Check that the path is correct and the file is accessible");
        }

        // Detect TypeScript files by extension
        let is_typescript = path.extension()
            .and_then(|s| s.to_str())
            .map(|ext| ext == "ts" || ext == "tsx")
            .unwrap_or(false);

        // TypeScript handlers: Check Bun is installed
        if is_typescript {
            which::which("bun")
                .wrap_err("TypeScript handler requires Bun runtime")
                .with_help("Install Bun: curl -fsSL https://bun.sh/install | bash")?;
        }

        // Non-TypeScript handlers: Check executable bit on POSIX systems
        #[cfg(unix)]
        if !is_typescript {
            use std::os::unix::fs::PermissionsExt;
            let metadata = path.metadata()
                .wrap_err_with(|| format!("Failed to read metadata for {}", path.display()))?;
            let permissions = metadata.permissions();

            if permissions.mode() & 0o111 == 0 {
                return Err(eyre!("Handler file is not executable: {}", path.display()))
                    .with_help(format!("Run: chmod +x {}", path.display()));
            }
        }

        Ok(Self { path, is_typescript })
    }

    /// Execute handler in background with timeout (non-blocking)
    fn execute(&self, event_name: &str, event_json: &str) -> Result<()> {
        let path = self.path.clone();
        let is_typescript = self.is_typescript;
        let event_name = event_name.to_string();
        let event_json = event_json.to_string();

        // Execute in background thread (non-blocking)
        std::thread::spawn(move || {
            let result = Self::execute_with_timeout(
                &path,
                &event_name,
                &event_json,
                is_typescript,
                Duration::from_secs(30),
            );

            if let Err(e) = result {
                eprintln!("Handler {} failed: {}", path.display(), e);
            }
        });

        Ok(())
    }

    /// Execute handler with timeout (blocking, used by background thread)
    fn execute_with_timeout(
        path: &Path,
        event_name: &str,
        event_json: &str,
        is_typescript: bool,
        timeout: Duration,
    ) -> Result<()> {
        use std::sync::mpsc;

        let (tx, rx) = mpsc::channel();
        let path = path.to_path_buf();
        let event_name = event_name.to_string();
        let event_json = event_json.to_string();

        // Spawn execution thread
        std::thread::spawn(move || {
            let output = if is_typescript {
                // Execute TypeScript handler with Bun
                std::process::Command::new("bun")
                    .arg(&path)
                    .env("TA_EVENT", &event_name)
                    .env("TA_EVENT_DATA", &event_json)
                    .output()
            } else {
                // Execute shell script handler
                std::process::Command::new(&path)
                    .env("TA_EVENT", &event_name)
                    .env("TA_EVENT_DATA", &event_json)
                    .output()
            };

            let _ = tx.send(output);
        });

        // Wait for execution with timeout
        match rx.recv_timeout(timeout) {
            Ok(Ok(output)) => {
                // Check exit status
                if !output.status.success() {
                    eprintln!("Handler {} exited with status: {}", path.display(), output.status);
                    eprintln!("stderr: {}", String::from_utf8_lossy(&output.stderr));
                } else {
                    // Log stdout for debugging
                    let stdout = String::from_utf8_lossy(&output.stdout);
                    if !stdout.is_empty() {
                        eprintln!("Handler output: {}", stdout);
                    }
                }
                Ok(())
            }
            Ok(Err(e)) => {
                Err(eyre!("Handler execution failed: {}", e))
            }
            Err(_) => {
                Err(eyre!("Handler timed out after {:?}", timeout))
            }
        }
    }
}
```

**Key Design Decisions:**

1. **Non-blocking execution:** `execute()` spawns thread, returns immediately
2. **Timeout handling:** 30 second timeout via `recv_timeout()`
3. **Cross-platform:** Uses `which` crate for Bun detection (works on Windows)
4. **Environment variables:** `TA_EVENT` (event name) + `TA_EVENT_DATA` (JSON)
5. **Error resilience:** Handler failures logged but don't crash watcher

---

#### Step 3: Update `CliWatchHandler` to Dispatch to Handlers

**File:** `/Volumes/coding/personal/ta/cli/src/commands/watch.rs`

**Location:** Replace lines 39-59 (existing `CliWatchHandler`)

```rust
use std::collections::HashMap;
use ta_lib::watcher::{WatchHandler, WatchEvent};

/// CLI watch handler that dispatches to external handlers
struct CliWatchHandler {
    format: OutputFormat,
    handlers: HashMap<String, ValidatedHandler>,
    generic_handler: Option<ValidatedHandler>,
}

impl CliWatchHandler {
    fn new(format: OutputFormat, args: &WatchArgs) -> Result<Self> {
        let mut handlers = HashMap::new();

        // Validate and register event-specific handlers
        if let Some(path) = &args.on_symbol_added {
            handlers.insert("SymbolAdded".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_symbol_removed {
            handlers.insert("SymbolRemoved".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_test_status_changed {
            handlers.insert("TestStatusChanged".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_new_failing_test {
            handlers.insert("NewFailingTest".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_test_fixed {
            handlers.insert("TestFixed".to_string(), ValidatedHandler::new(path.clone())?);
        }
        if let Some(path) = &args.on_new_test_added {
            handlers.insert("NewTestAdded".to_string(), ValidatedHandler::new(path.clone())?);
        }

        // Generic handler for all events
        let generic_handler = args.on_any_event
            .as_ref()
            .map(|path| ValidatedHandler::new(path.clone()))
            .transpose()?;

        Ok(Self {
            format,
            handlers,
            generic_handler,
        })
    }

    /// Dispatch event to registered handlers
    fn dispatch_event(&self, event_name: &str, event_data: &serde_json::Value) -> Result<()> {
        let event_json = serde_json::to_string(event_data)?;

        // Execute event-specific handler if registered
        if let Some(handler) = self.handlers.get(event_name) {
            handler.execute(event_name, &event_json)?;
        }

        // Execute generic handler if registered
        if let Some(handler) = &self.generic_handler {
            handler.execute(event_name, &event_json)?;
        }

        // Always log to console (existing behavior)
        eprintln!("[{}] {}", event_name, event_json);

        Ok(())
    }
}

impl WatchHandler for CliWatchHandler {
    fn handle_event(&mut self, event: &WatchEvent) {
        // Map WatchEvent variant to event name
        let event_name = match event {
            WatchEvent::SymbolAdded { .. } => "SymbolAdded",
            WatchEvent::SymbolRemoved { .. } => "SymbolRemoved",
            WatchEvent::TestStatusChanged { .. } => "TestStatusChanged",
            WatchEvent::NewFailingTest { .. } => "NewFailingTest",
            WatchEvent::TestFixed { .. } => "TestFixed",
            WatchEvent::NewTestAdded { .. } => "NewTestAdded",
            _ => return, // Ignore other events
        };

        // Serialize event data to JSON
        let data = serde_json::to_value(event)
            .unwrap_or_else(|_| serde_json::json!({}));

        // Dispatch to handlers (errors logged, don't crash)
        let _ = self.dispatch_event(event_name, &data);
    }
}
```

**Note:** This assumes `WatchEvent` enum has the listed variants. Check `/Volumes/coding/personal/ta/lib/src/watcher.rs` for actual variant names and adjust as needed.

---

#### Step 4: Update `handle_watch()` Function

**File:** `/Volumes/coding/personal/ta/cli/src/commands/watch.rs`

**Location:** Replace existing `handle_watch()` (around line 45)

```rust
pub fn handle_watch(args: WatchArgs) -> Result<()> {
    // Create handler with validation
    let handler = CliWatchHandler::new(args.format, &args)?;

    // Create file watcher
    let mut watcher = ta_lib::watcher::FileWatcher::new(Box::new(handler))
        .wrap_err("Failed to create file watcher")?;

    // Register watch paths
    for path in &args.paths {
        watcher.watch(path).wrap_err_with(|| {
            format!("Failed to watch path: {}", path.display())
        })?;
    }

    println!("Watching {} path(s) for changes. Press Ctrl+C to stop.", args.paths.len());

    // Run watcher (blocks until Ctrl+C)
    watcher.run().wrap_err("File watcher encountered an error")?;

    Ok(())
}
```

---

### Testing Strategy

#### Unit Tests (`#[cfg(test)] mod tests` in `watch.rs`)

**Location:** Add at end of `/Volumes/coding/personal/ta/cli/src/commands/watch.rs`

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::env;

    #[test]
    fn test_validated_handler_with_nonexistent_file() {
        let path = PathBuf::from("/nonexistent/handler.sh");
        let result = ValidatedHandler::new(path);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("does not exist"));
    }

    #[test]
    #[cfg(unix)]
    fn test_validated_handler_with_non_executable_file() {
        use std::os::unix::fs::PermissionsExt;

        // Create temp non-executable script
        let temp_dir = env::temp_dir();
        let script_path = temp_dir.join("test-non-executable.sh");
        fs::write(&script_path, "#!/bin/bash\necho test").unwrap();
        fs::set_permissions(&script_path, fs::Permissions::from_mode(0o644)).unwrap();

        let result = ValidatedHandler::new(script_path.clone());
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("not executable"));

        // Cleanup
        let _ = fs::remove_file(script_path);
    }

    #[test]
    #[cfg(unix)]
    fn test_validated_handler_with_executable_file() {
        use std::os::unix::fs::PermissionsExt;

        // Create temp executable script
        let temp_dir = env::temp_dir();
        let script_path = temp_dir.join("test-executable.sh");
        fs::write(&script_path, "#!/bin/bash\necho test").unwrap();
        fs::set_permissions(&script_path, fs::Permissions::from_mode(0o755)).unwrap();

        let result = ValidatedHandler::new(script_path.clone());
        assert!(result.is_ok());
        assert!(!result.unwrap().is_typescript);

        // Cleanup
        let _ = fs::remove_file(script_path);
    }

    #[test]
    fn test_typescript_handler_detection() {
        // Create temp TypeScript file
        let temp_dir = env::temp_dir();
        let ts_path = temp_dir.join("test-handler.ts");
        fs::write(&ts_path, "console.log('test')").unwrap();

        let result = ValidatedHandler::new(ts_path.clone());

        // Result depends on whether Bun is installed
        if which::which("bun").is_ok() {
            assert!(result.is_ok());
            assert!(result.unwrap().is_typescript);
        } else {
            assert!(result.is_err());
            assert!(result.unwrap_err().to_string().contains("Bun"));
        }

        // Cleanup
        let _ = fs::remove_file(ts_path);
    }

    #[test]
    fn test_handler_execution_with_env_vars() {
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;

            // Create temp script that echoes env vars to a temp file
            let temp_dir = env::temp_dir();
            let script_path = temp_dir.join("test-env-handler.sh");
            let output_path = temp_dir.join("test-env-output.txt");

            let script_content = format!(
                "#!/bin/bash\necho \"Event: $TA_EVENT\" > {}\necho \"Data: $TA_EVENT_DATA\" >> {}",
                output_path.display(),
                output_path.display()
            );

            fs::write(&script_path, script_content).unwrap();
            fs::set_permissions(&script_path, fs::Permissions::from_mode(0o755)).unwrap();

            let handler = ValidatedHandler::new(script_path.clone()).unwrap();

            // Execute with test data
            let event_json = r#"{"file": "test.ts", "symbol": "foo"}"#;
            ValidatedHandler::execute_with_timeout(
                &handler.path,
                "SymbolAdded",
                event_json,
                false,
                Duration::from_secs(5),
            ).unwrap();

            // Wait for execution
            std::thread::sleep(Duration::from_millis(100));

            // Verify output
            let output = fs::read_to_string(&output_path).unwrap();
            assert!(output.contains("Event: SymbolAdded"));
            assert!(output.contains("Data: {\"file\": \"test.ts\""));

            // Cleanup
            let _ = fs::remove_file(script_path);
            let _ = fs::remove_file(output_path);
        }
    }
}
```

**Test Coverage:**
- ✅ Non-existent handler file
- ✅ Non-executable handler (POSIX)
- ✅ Executable handler validation (POSIX)
- ✅ TypeScript file detection
- ✅ Bun availability check
- ✅ Environment variable passing
- ✅ Handler execution with timeout

---

#### Integration Test

**File:** `/Volumes/coding/personal/ta/cli/tests/integration_test.rs`

**Location:** Add at end of file

```rust
#[test]
#[cfg(unix)]
fn test_watch_with_handler() {
    use std::fs;
    use std::os::unix::fs::PermissionsExt;
    use std::env;

    // Create temp handler script
    let temp_dir = env::temp_dir();
    let script_path = temp_dir.join("integration-test-handler.sh");
    let output_path = temp_dir.join("integration-test-output.txt");

    let script_content = format!(
        "#!/bin/bash\necho \"$TA_EVENT\" > {}",
        output_path.display()
    );

    fs::write(&script_path, script_content).unwrap();
    fs::set_permissions(&script_path, fs::Permissions::from_mode(0o755)).unwrap();

    // Note: Actual watch testing is complex (requires file modification + delay)
    // This test just verifies the CLI accepts the flag
    ta_cmd()
        .arg("watch")
        .arg(fixtures_dir())
        .arg("--Handler")
        .arg(&script_path)
        .timeout(std::time::Duration::from_secs(2))
        .assert()
        .success();  // Should start successfully

    // Cleanup
    let _ = fs::remove_file(script_path);
    let _ = fs::remove_file(output_path);
}
```

**Note:** Full end-to-end watch testing (file modification → handler execution) is complex and may require a dedicated test harness. This test verifies CLI accepts the flag and starts the watcher.

---

### Acceptance Criteria

- [ ] **File Modified:** `/Volumes/coding/personal/ta/cli/Cargo.toml` - Add `which = "6.0"` dependency
- [ ] **File Modified:** `/Volumes/coding/personal/ta/cli/src/commands/watch.rs` (250+ new lines)
  - [ ] `WatchArgs` has handler fields: `on_symbol_added`, `on_symbol_removed`, etc.
  - [ ] `ValidatedHandler` struct implemented with validation logic
  - [ ] `ValidatedHandler::new()` checks: file exists, executable (POSIX), Bun available (TS)
  - [ ] `ValidatedHandler::execute()` spawns background thread (non-blocking)
  - [ ] `ValidatedHandler::execute_with_timeout()` implements 30s timeout
  - [ ] `CliWatchHandler` uses `HashMap<String, ValidatedHandler>` for dispatch
  - [ ] `CliWatchHandler::dispatch_event()` calls handlers with JSON event data
- [ ] **Tests Added:** `watch.rs` `#[cfg(test)]` module with 5+ unit tests
- [ ] **Test Added:** `integration_test.rs` - `test_watch_with_handler()`
- [ ] **Build Succeeds:** `cargo build --release` passes
- [ ] **Tests Pass:** `cargo test` (full suite) passes
- [ ] **Clippy Clean:** `cargo clippy` shows no new warnings
- [ ] **Manual Tests:**
  - [ ] `ta watch --help` shows new `--${Event}` flags
  - [ ] Create test handler: `echo '#!/bin/bash' > test.sh && echo 'echo "Event: $TA_EVENT"' >> test.sh && chmod +x test.sh`
  - [ ] Run: `ta watch cli/tests/fixtures/ --Handler ./test.sh`
  - [ ] Modify a file in fixtures → handler executes, logs to console
  - [ ] Handler with non-existent file → error with help text before watch starts
  - [ ] Handler without execute permission → error with help text and `chmod` suggestion
  - [ ] TypeScript handler without Bun → error with Bun installation help text

---

## Parallelization Opportunities

N/A - Single phase implementation.

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Handler execution blocks file watching | High | Low | Non-blocking execution via `std::thread::spawn` |
| Handler hangs indefinitely | Medium | Medium | 30 second timeout via `recv_timeout()` |
| Bun not installed for TypeScript handlers | Medium | Medium | Validate during `CliWatchHandler::new()`, fail early with help text |
| Handler spawns orphan processes | Low | Low | Handlers run in separate process tree, terminated on timeout |
| Environment variable size limits | Low | Low | Document limit (typically 128KB), consider stdin for large events |
| Cross-platform execution differences | Medium | Low | Use `which` crate for binary detection, platform-specific tests |

---

## Open Questions

- [ ] **Should handlers be async (tokio)?**
  - **Decision:** No, use `std::thread` for v1.0. Tokio adds significant dependency weight.

- [ ] **Should handler timeout be configurable?**
  - **Decision:** Hardcode 30s for v1.0, can add `--handler-timeout` flag in future.

- [ ] **Should handler failures stop the watcher?**
  - **Decision:** No, log errors but continue watching. Resilience over strictness.

- [ ] **Should we validate handler output (exit codes)?**
  - **Decision:** Log non-zero exit codes but don't treat as fatal errors.

---

## Review Summary

**Reviews Completed:** 2025-12-22

**Reviewers:**
- **Rust Developer:** Approve with Changes
- **Feature Tester (Rust):** Request Revision → Approved after plan update

**Key Changes from Review:**

1. **Removed Phase 1 (Test Filtering)** - Already implemented in `source.rs:68-77`
2. **Removed Phase 2 (Glob Validation)** - Not applicable; uses substring filters, no security issue
3. **Enhanced Phase 3 (Handler Execution):**
   - Added `which` crate for cross-platform Bun detection
   - Implemented non-blocking execution via `std::thread::spawn`
   - Added 30 second timeout via `std::sync::mpsc::recv_timeout()`
   - Added comprehensive unit tests (5+ tests)
   - Added integration test with temp handler scripts
   - Improved error messages with `.with_help()` guidance

**Resolved Concerns:**
- **Non-blocking execution:** Handlers execute in background threads
- **Bun validation:** Check `which::which("bun")` during handler validation
- **Timeout handling:** 30s timeout prevents indefinite hangs
- **Test isolation:** Unit tests use temp files for verification
- **Cross-platform:** Uses `which` crate, works on Unix and Windows

---

## Implementation Checklist

### Pre-Implementation
- [ ] Review plan with team
- [ ] Verify Bun is installed for testing TypeScript handlers
- [ ] Create feature branch: `git checkout -b feat/watch-handler-execution`

### Implementation
- [ ] Add `which = "6.0"` to `cli/Cargo.toml`
- [ ] Extend `WatchArgs` with handler CLI flags
- [ ] Implement `ValidatedHandler` struct
- [ ] Update `CliWatchHandler` to dispatch to handlers
- [ ] Update `handle_watch()` function
- [ ] Add unit tests (5+ tests)
- [ ] Add integration test
- [ ] Run `cargo build --release` (verify compiles)
- [ ] Run `cargo test` (verify all tests pass)
- [ ] Run `cargo clippy` (verify no new warnings)

### Manual Testing
- [ ] Test with shell script handler
- [ ] Test with TypeScript handler (requires Bun)
- [ ] Test with non-existent handler → verify error
- [ ] Test with non-executable handler → verify error + help text
- [ ] Test with missing Bun → verify error + install help text
- [ ] Test generic `--Handler` flag
- [ ] Test multiple event handlers simultaneously
- [ ] Verify handler failures don't crash watcher

### Post-Implementation
- [ ] Update README with handler usage examples
- [ ] Update CLAUDE.md known issues (remove "External handler execution")
- [ ] Create pull request
- [ ] Request code review
- [ ] Merge to main after approval

---

## Success Metrics

- [ ] Zero new clippy warnings
- [ ] All existing tests pass
- [ ] 100% of new functions have unit tests
- [ ] Manual testing checklist: 8/8 tests pass
- [ ] Handler execution is non-blocking (verified via debug logging)
- [ ] Handler timeouts work (verified with sleep command)
- [ ] TypeScript handlers execute via Bun (verified with `.ts` file)

---

## Next Steps After Implementation

1. **Update documentation:**
   - Add handler examples to README
   - Document environment variables (`TA_EVENT`, `TA_EVENT_DATA`)
   - Add TypeScript handler template in `/examples`

2. **Future enhancements (post-v1.0):**
   - Make timeout configurable via `--handler-timeout` flag
   - Add `--verbose` flag to show all handler output
   - Support passing event data via stdin (for large payloads)
   - Add handler retry logic for transient failures
   - Implement remaining watch events (SourceFileChanged, ModuleDepChanged, etc.)

3. **Performance testing:**
   - Benchmark handler overhead with multiple simultaneous events
   - Verify no memory leaks from background threads
   - Test with long-running watcher sessions (hours)

---

## Appendix: WatchEvent Enum Check

**Action Required:** Verify the actual `WatchEvent` enum structure in `/Volumes/coding/personal/ta/lib/src/watcher.rs` and adjust the `CliWatchHandler::handle_event()` implementation if the variant names differ.

**Expected Structure:**
```rust
pub enum WatchEvent {
    SymbolAdded { file: String, symbol: Symbol },
    SymbolRemoved { file: String, symbol: Symbol },
    TestStatusChanged { file: String, test: Test },
    NewFailingTest { file: String, test: Test },
    TestFixed { file: String, test: Test },
    NewTestAdded { file: String, test: Test },
    // ... other variants
}
```

If the structure differs, update the `match` statement in `handle_event()` accordingly.
